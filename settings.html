<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Survey Brain – Settings</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script type="module" src="./js/themeSettings.js"></script>
  <script>
    (function () {
      const key = "depot.themePreference";
      const saved = localStorage.getItem(key);
      const validThemes = ["blue", "green"];
      const theme = validThemes.includes(saved) ? saved : "blue";
      document.documentElement.dataset.theme = theme;
    })();
  </script>
  <style>
    :root {
      /* Metal Control Deck Theme */
      --bg: #1a1d24;
      --card: linear-gradient(145deg, #2a2f3a 0%, #363c4a 50%, #2a2f3a 100%);
      --border: #4a5568;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --muted: #94a3b8;
      --danger: #ef4444;
      --radius: 4px;
      --screen-glow: 0 0 20px rgba(37, 99, 235, 0.25);
      --metal-shine: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0) 100%);
      --button-inset: inset 2px 2px 5px rgba(0,0,0,0.4), inset -2px -2px 5px rgba(255,255,255,0.1);
      --screen-bg: linear-gradient(180deg, #0f1419 0%, #1a1f29 100%);
    }

    :root[data-theme="green"] {
      --accent: #10b981;
      --accent-soft: #34d399;
      --screen-glow: 0 0 20px rgba(16, 185, 129, 0.3);
    }
    * { box-sizing: border-box; }

    @keyframes screenFlicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.98; }
    }

    @keyframes ledPulse {
      0%, 100% { box-shadow: 0 0 5px currentColor, 0 0 10px currentColor; }
      50% { box-shadow: 0 0 10px currentColor, 0 0 20px currentColor; }
    }

    @keyframes metalShimmer {
      0% { background-position: -200% center; }
      100% { background-position: 200% center; }
    }

    body {
      margin: 0;
      font-family: 'Courier New', 'Consolas', monospace;
      background:
        repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0px, transparent 1px, transparent 2px, rgba(0,0,0,0.1) 3px),
        radial-gradient(circle at top, #2d3748 0%, var(--bg) 60%);
      color: #e2e8f0;
      min-height: 100vh;
      padding: 16px;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        repeating-linear-gradient(90deg, transparent 0px, rgba(0,255,0,0.03) 1px, transparent 2px),
        repeating-linear-gradient(0deg, transparent 0px, rgba(0,255,0,0.03) 1px, transparent 2px);
      background-size: 2px 2px;
      pointer-events: none;
      z-index: 1;
      animation: screenFlicker 3s infinite;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 16px;
      padding: 16px;
      background: var(--card);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--button-inset);
      position: relative;
      z-index: 2;
    }

    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      animation: metalShimmer 3s linear infinite;
      background-size: 200% 100%;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--accent);
      text-shadow: 0 0 10px var(--accent), 0 0 20px var(--accent);
      font-weight: 700;
    }

    header span {
      font-size: .75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    a.back-link {
      margin-left: auto;
      font-size: .8rem;
      color: #7dd3fc;
      text-decoration: none;
    }
    a.back-link:hover {
      text-decoration: underline;
    }
    main {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 14px;
      position: relative;
      z-index: 2;
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      border: 2px solid var(--border);
      padding: 16px 18px 18px;
      color: #e2e8f0;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: var(--button-inset), 0 4px 12px rgba(0,0,0,0.4);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(16, 185, 129, 0.5), transparent);
    }

    .card::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--metal-shine);
      background-size: 200% 100%;
      opacity: 0.05;
      pointer-events: none;
    }
    .card-header {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .card-header h2 {
      margin: 0;
      font-size: .9rem;
      text-transform: uppercase;
      letter-spacing: .1em;
      color: var(--accent);
      text-shadow: 0 0 5px var(--accent);
      font-weight: 700;
    }
    .card-header span {
      font-size: .7rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 4px;
    }
    button {
      border: 2px solid var(--border);
      border-radius: var(--radius);
      padding: 8px 16px;
      font-size: .7rem;
      font-weight: 700;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(145deg, var(--accent) 0%, #059669 100%);
      color: #fff;
      white-space: nowrap;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2), inset 0 -1px 0 rgba(0,0,0,0.3);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
      font-family: 'Courier New', 'Consolas', monospace;
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      transform: translate(-50%, -50%);
      transition: width 0.3s, height 0.3s;
    }

    button:hover:not(:disabled)::before {
      width: 300px;
      height: 300px;
    }

    button:hover:not(:disabled) {
      background: linear-gradient(145deg, var(--accent-soft) 0%, var(--accent) 100%);
      box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3), inset 0 -1px 0 rgba(0,0,0,0.3);
    }

    button:active:not(:disabled) {
      box-shadow: var(--button-inset);
      transform: translateY(1px);
    }

    button.secondary {
      background: linear-gradient(145deg, #475569 0%, #334155 100%);
      color: #e2e8f0;
    }

    button.secondary:hover:not(:disabled) {
      background: linear-gradient(145deg, #64748b 0%, #475569 100%);
    }

    button.danger {
      background: linear-gradient(145deg, var(--danger) 0%, #dc2626 100%);
      color: white;
    }

    button.danger:hover:not(:disabled) {
      background: linear-gradient(145deg, #f87171 0%, var(--danger) 100%);
    }

    button.small {
      padding: 4px 10px;
      font-size: .65rem;
      font-weight: 600;
    }

    button:disabled {
      opacity: .4;
      cursor: not-allowed;
      background: linear-gradient(145deg, #374151 0%, #1f2937 100%);
      color: #6b7280;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: .65rem;
      border-radius: var(--radius);
      padding: 4px 10px;
      background: linear-gradient(145deg, #1f2937 0%, #111827 100%);
      color: var(--accent);
      border: 1px solid var(--border);
      box-shadow: inset 1px 1px 2px rgba(0,0,0,0.4);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 600;
    }
    .pill.small {
      font-size: .6rem;
      padding: 3px 8px;
    }
    .pill-tag {
      background: linear-gradient(145deg, #1f2937 0%, #111827 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 3px 8px;
      font-size: .6rem;
      color: var(--accent);
      box-shadow: inset 1px 1px 2px rgba(0,0,0,0.4);
    }
    .rows {
      border-radius: var(--radius);
      border: 2px solid var(--border);
      max-height: 60vh;
      overflow: auto;
      background: var(--screen-bg);
      box-shadow: inset 2px 2px 8px rgba(0,0,0,0.6);
    }
    .row {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) minmax(0, 2fr) auto;
      gap: 6px;
      padding: 8px 10px;
      align-items: flex-start;
      border-bottom: 1px solid rgba(74, 85, 104, 0.3);
    }
    .row:last-child {
      border-bottom: none;
    }
    .row span.order {
      font-size: .65rem;
      color: var(--accent);
      min-width: 2rem;
      font-weight: 700;
      text-shadow: 0 0 5px var(--accent);
    }
    .row input[type="text"] {
      width: 100%;
      font-size: .7rem;
      padding: 6px 8px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(145deg, #1a1f29 0%, #0f1419 100%);
      color: var(--accent);
      font-family: 'Courier New', 'Consolas', monospace;
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5);
    }

    .row input[type="text"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5), 0 0 8px rgba(16, 185, 129, 0.4);
    }

    .row textarea {
      width: 100%;
      font-size: .7rem;
      padding: 6px 8px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(145deg, #1a1f29 0%, #0f1419 100%);
      color: var(--accent);
      font-family: 'Courier New', 'Consolas', monospace;
      resize: vertical;
      min-height: 42px;
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5);
    }

    .row textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5), 0 0 8px rgba(16, 185, 129, 0.4);
    }
    .row-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .checklist-rows {
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      max-height: 60vh;
      overflow: auto;
    }
    .checklist-row {
      display: grid;
      grid-template-columns: auto minmax(0, 0.9fr) minmax(0, 1fr) minmax(0, 1.4fr) minmax(0, 2fr) minmax(0, 1fr) auto auto;
      gap: 4px;
      padding: 6px 8px;
      align-items: flex-start;
      border-bottom: 1px solid #e2e8f0;
    }
    .checklist-row:last-child {
      border-bottom: none;
    }
    .checklist-row span.order {
      font-size: .65rem;
      color: var(--muted);
      min-width: 1.5rem;
    }
    .checklist-row input[type="text"] {
      width: 100%;
      font-size: .65rem;
      padding: 3px 4px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
    }
    .status {
      font-size: .65rem;
      color: var(--muted);
      margin-top: 4px;
      font-family: 'Courier New', 'Consolas', monospace;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .status strong {
      color: var(--accent);
      text-shadow: 0 0 5px var(--accent);
    }
    .status.error strong {
      color: var(--danger);
      text-shadow: 0 0 5px var(--danger);
    }
    .hint {
      font-size: .65rem;
      color: var(--muted);
      font-family: 'Courier New', 'Consolas', monospace;
      line-height: 1.4;
    }
    .rule-rows {
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      max-height: 50vh;
      overflow: auto;
    }
    .rule-row {
      display: grid;
      grid-template-columns: minmax(0, 0.4fr) minmax(0, 1.6fr);
      gap: 8px;
      padding: 8px 10px;
      align-items: start;
      border-bottom: 1px solid #e2e8f0;
    }
    .rule-row:last-child {
      border-bottom: none;
    }
    .rule-row strong {
      font-size: .75rem;
      color: #0f172a;
    }
    .rule-row textarea {
      width: 100%;
      font-size: .7rem;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      resize: vertical;
      min-height: 72px;
    }
    .rule-instructions {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .rule-instructions .hint {
      margin: 0;
    }
  </style>
</head>
<body>
  <header>
    <h1>Survey Brain Settings</h1>
    <span>Section schema & checklist config</span>
    <div id="authStatus" style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
      <span id="userDisplay" style="font-size: 0.75rem; color: #7dd3fc;"></span>
      <button id="loginBtn" class="secondary" style="font-size: 0.7rem; padding: 4px 10px;">Sign In</button>
      <button id="logoutBtn" class="secondary" style="font-size: 0.7rem; padding: 4px 10px; display: none;">Sign Out</button>
    </div>
    <button id="forceReloadBtn" class="danger">Force reload / reset app data</button>
    <a href="index.html" class="back-link">← Back to app</a>
  </header>

  <main>
    <!-- Cloud Sync Section -->
    <section class="card" style="grid-column: 1 / -1;" id="cloudSyncSection">
      <div class="card-header">
        <h2>Cloud Sync</h2>
        <span>Sync settings across devices</span>
      </div>

      <div class="toolbar">
        <button id="syncToCloudBtn" class="secondary">↑ Save to Cloud</button>
        <button id="syncFromCloudBtn" class="secondary">↓ Load from Cloud</button>
      </div>

      <p class="hint">
        Sign in to sync your settings, sections, checklist, and AI instructions across all your devices.
        Your data is securely stored and only accessible with your account.
      </p>

      <p class="status" id="syncStatus"></p>
    </section>

    <!-- Export Format Preferences -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Export Format</h2>
        <span>Choose default file format for exports</span>
      </div>
      <div style="display: flex; gap: 12px; align-items: center;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="radio" name="exportFormat" value="json" id="formatJSON" checked>
          <span style="font-size: 0.75rem; font-weight: 600;">JSON (default)</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="radio" name="exportFormat" value="csv" id="formatCSV">
          <span style="font-size: 0.75rem; font-weight: 600;">CSV (Comma-Separated Values)</span>
        </label>
      </div>
      <p class="hint">
        This setting controls the format used when exporting notes, sessions, and automatic/AI notes.
        JSON exports include all data in a structured format, while CSV exports are optimized for spreadsheet applications.
      </p>
    </section>

    <!-- Colour Theme Preferences -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Colour theme</h2>
        <span>Pick an accent colour for the app</span>
      </div>

      <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
        <label for="colorThemeSelect" style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">Accent colour</label>
        <select id="colorThemeSelect" style="padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border); background: var(--card); color: #e2e8f0; box-shadow: var(--button-inset);">
          <option value="blue">Blue (default)</option>
          <option value="green">Green</option>
        </select>
      </div>

      <p class="hint">Changing the accent colour updates buttons, highlights, and other green elements throughout the app.</p>
    </section>

    <!-- AI Instructions Configuration -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>AI Instructions</h2>
        <span>Customize system prompts for AI agents</span>
      </div>

      <div class="toolbar">
        <button id="ai-save-btn" class="secondary">Save AI Instructions</button>
        <button id="ai-reset-btn" class="secondary">Reset to Defaults</button>
      </div>

      <p class="hint">
        These instructions control how the AI behaves in different contexts. Edit them to customize the AI's behavior for your specific needs.
      </p>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <label style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">Agent Chat Instructions</label>
          <textarea
            id="ai-agent-chat-instructions"
            style="font-family: monospace; font-size: 0.7rem; padding: 8px; border: 1px solid var(--border); border-radius: 8px; min-height: 300px; resize: vertical;"
            placeholder="Agent chat system prompt..."
          ></textarea>
          <p class="hint" style="margin: 0;">Used when the AI assistant chats with you about survey details.</p>
        </div>

        <div style="display: flex; flex-direction: column; gap: 8px;">
          <label style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">Section Tweak Instructions</label>
          <textarea
            id="ai-tweak-section-instructions"
            style="font-family: monospace; font-size: 0.7rem; padding: 8px; border: 1px solid var(--border); border-radius: 8px; min-height: 300px; resize: vertical;"
            placeholder="Section tweak system prompt..."
          ></textarea>
          <p class="hint" style="margin: 0;">Used when the AI improves survey section notes based on your instructions.</p>
        </div>
      </div>

      <p class="status" id="ai-status"></p>
    </section>

    <!-- LEFT: section schema editor -->
    <section class="card">
      <div class="card-header">
        <h2>Notes sections</h2>
        <span>Edit the section list & order</span>
        <span class="pill small" id="sections-count-pill">0 sections</span>
      </div>

      <div class="toolbar">
        <button id="sections-add-btn">+ Add section</button>
        <button id="sections-save-btn" class="secondary">Save to browser</button>
        <button id="sections-export-btn" class="secondary">Export JSON</button>
        <button id="sections-import-btn" class="secondary">Import JSON</button>
      </div>
      <p class="hint">
        These control the section headings in the main app. The worker fills them with text, but the
        <strong>names & order are defined here</strong>. “Future plans” will always be kept last by the app.
      </p>

      <div class="rows" id="sections-rows"></div>

      <p class="status" id="sections-status">Loading sections…</p>
      <input type="file" id="sections-import-input" accept="application/json" style="display:none;">
    </section>

    <!-- Section rules guidance -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Notes section rules</h2>
        <span>What content belongs in each section</span>
      </div>

      <div class="toolbar">
        <button id="section-rules-save-btn" class="secondary">Save rules to browser</button>
        <button id="section-rules-reset-btn" class="secondary">Reset rules to defaults</button>
      </div>

        <p class="hint">
          Use these rules to spell out what should go into each notes section. The text is shown as editable AI instructions for
          every section, so you can keep guidance in sync with how your team captures information. Keep the "New boiler and controls" rules short and focused: what is coming out,
          what is being installed, which controls stay or change, where everything sits, and details of any cylinders, tanks,
          sealed system kits, and radiators.
        </p>

      <div class="rule-rows" id="section-rules-rows"></div>
      <p class="status" id="section-rules-status">Loading section rules…</p>

      <!-- AI Instructions for Notes Generation -->
      <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
        <h3 style="margin: 0; font-size: 0.9rem; letter-spacing: .02em;">AI Instructions for Notes Generation</h3>
        <div style="display: flex; flex-direction: column; gap: 6px; margin-top: 8px;">
          <label for="notes-instructions" style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">
            AI instructions for notes
          </label>
          <textarea
            id="notes-instructions"
            style="font-family: monospace; font-size: 0.7rem; padding: 8px; border: 1px solid var(--border); border-radius: 8px; min-height: 280px; resize: vertical;"
            placeholder="Notes system prompt..."
            spellcheck="false"
          ></textarea>
        </div>

        <button id="notes-reset-btn" type="button" class="secondary">Reset to recommended notes rules</button>
      </div>
    </section>

    <!-- RIGHT: checklist editor -->
    <section class="card">
      <div class="card-header">
        <h2>Survey checklist</h2>
        <span>Groups, IDs & hints</span>
        <span class="pill small" id="checklist-count-pill">0 items</span>
      </div>

      <div class="toolbar">
        <button id="checklist-add-btn">+ Add item</button>
        <button id="checklist-save-btn" class="secondary">Save to browser</button>
        <button id="checklist-export-btn" class="secondary">Export JSON</button>
        <button id="checklist-import-btn" class="secondary">Import JSON</button>
      </div>
        <p class="hint">
          Each item has a stable <strong>ID</strong>, a <strong>group</strong> label, an optional
          <strong>section link</strong>, plus a visible label and hint. Click <strong>⋯</strong> to expand and edit
          <strong>AI templates</strong> (plainText & naturalLanguage). The worker uses these templates to generate section content.
        </p>

      <div class="checklist-rows" id="checklist-rows"></div>

      <p class="status" id="checklist-status">Loading checklist…</p>
      <input type="file" id="checklist-import-input" accept="application/json" style="display:none;">
    </section>
  </main>

  <script>
    // Storage keys (match index.html)
    const SECTION_STORAGE_KEY = "depot.sectionSchema";
    const LEGACY_SECTION_STORAGE_KEY = "surveybrain-schema";
    const CHECKLIST_STORAGE_KEY = "depot.checklistConfig";
    const SECTION_RULES_STORAGE_KEY = "depot.sectionRules";
    const AI_INSTRUCTIONS_STORAGE_KEY = "depot.aiInstructions";
    const DEFAULT_NOTES_INSTRUCTIONS = `
You are generating engineer-friendly "job notes" from a voice transcript for a domestic heating job.

General rules:
- Prefer clear, non-duplicated bullets.
- Avoid contradictions in the same section.
- When there is a conflict between earlier speculative text and later, typed "summary" lines from the adviser, ALWAYS prefer the later summary lines.
- Preserve the adviser's intent, not the raw transcription glitches.

High-priority source of truth:
- If the transcript contains a clearly typed list or short summary entered by the adviser (for example in a "Customer summary", "Engineer notes", or "typed notes" section), treat these as the final instructions.
- When such a summary contradicts earlier spoken content, follow the summary and drop the conflicting spoken content.

---

### Gas supply rules (Pipe work section)

When generating Pipe work bullets about the gas supply:

1. If the transcript contains phrases like:
   - "increase gas supply" OR "upgrade gas supply"
   AND
   - a route phrase such as "from meter", "via cupboards", "through cupboards", "along the same route", "to the boiler position"
   then:
   - Treat that as the authoritative gas instruction.
   - Generate ONE clear bullet describing the upgrade and route, for example:

     - "• Upgrade gas supply from meter via cupboards to new boiler position (size to suit 24kW boiler output plus diversity);"

   - Do NOT also generate a bullet stating that the "existing 15mm gas supply is adequate". Avoid any wording that contradicts the upgrade.

2. If the transcript only says the gas is adequate, with no "increase"/"upgrade" wording or route:
   - Generate a simple confirmation bullet, for example:

     - "• Existing gas supply confirmed adequate for new boiler;"

3. Never output both "existing 15mm gas supply confirmed adequate" AND "increase gas supply" in the same job. If upgrade wording is present, the upgrade wins and the "adequate" line should not appear.

---

### Primary pipework (primaries) rules (Pipe work section)

When generating Pipe work bullets about primaries (primary flow and return):

1. Look for phrases in the transcript such as:
   - "primaries", "primary pipework", "flow and return"
   AND
   - power or sizing context such as "set up for up to 18 kW", "you've got 24", "change them to 28mm", "24Ri", etc.

2. When these are present, generate two distinct bullets instead of a single vague one:

   - A route / location bullet tying the change to the physical path, for example:
     - "• Replace primary flow and return between loft hatches and airing cupboard;"

   - A sizing / justification bullet, for example:
     - "• Upgrade primary pipework to 28mm to allow full 24kW boiler output without overheating;"

3. Avoid vague or duplicate wording when the above bullets are used. For example, drop weaker lines like:
   - "Pipework between loft hatches and in airing cupboard to be replaced;"
   if they would duplicate a clearer, more explicit primaries bullet.

4. If the transcript clearly states that existing primaries are undersized (e.g. "current pipework is set up for up to 18kW and you’ve got 24"), ensure the notes include the reason:
   - Mention that the upgrade to 28mm is to match boiler output and reduce overheating / cycling.

---

### S-plan, pump, and open vent / cold feed assembly

When the transcript mentions replacing the pump, mid-position valve, or open vent / cold feed:

- Use clear, standard wording such as:
  - "• Replace primary pump and motorised valve assembly;"
  - "• Replace open vent and cold feed arrangement as part of system upgrade;"
  - "• Install new S-plan with two motorised valves (one heating, one hot water) and automatic bypass;"

- Normalise common mis-heard phrases:
  - "open venting code fade" → "open vent / cold feed arrangement".

---

### Brand and component clean-ups

Correct obvious transcription errors for well-known components:

- "Ferox TF1" → "Fernox TF1"
- Similar mis-spellings of common filters, inhibitors, and boiler models should be corrected to the standard brand spelling where unambiguous.

---

### General clean-up and de-duplication

- Remove "noise" bullets that do not contain a clear instruction or could cause confusion.
  - Example to drop: "possible issues with pipework in screening area;" if it has no route, size, or action.
- Favour fewer, clearer bullets over many vague ones.
- Where possible, make each bullet:
  - Specific to a location or route (e.g. "between loft hatches and airing cupboard").
  - Explicit about size or rating when changing pipework (e.g. "upgrade to 28mm").
  - Consistent with any final typed summary from the adviser.

Output concise, engineer-ready bullets in each section: no waffle, no contradictions, just what needs doing and why.
`;
    const LS_AUTOSAVE_KEY = "surveyBrainAutosave";
    const WORKER_URL_STORAGE_KEYS = ["depot.workerUrl", "depot-worker-url"];
    const ADDITIONAL_STORAGE_KEYS = [
      "depot-output-schema",
      "depot.notesSchema.v1",
      "depot-checklist-state"
    ];
    const FUTURE_PLANS_NAME = "Future plans";

    // --- Helpers ---
    function readJSONSafe(key) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (_) {
        return null;
      }
    }

    function clearStoredAppData() {
      const keys = new Set([
        SECTION_STORAGE_KEY,
        LEGACY_SECTION_STORAGE_KEY,
        CHECKLIST_STORAGE_KEY,
        SECTION_RULES_STORAGE_KEY,
        LS_AUTOSAVE_KEY,
        ...WORKER_URL_STORAGE_KEYS,
        ...ADDITIONAL_STORAGE_KEYS
      ]);

      try {
        for (let i = 0; i < localStorage.length; i += 1) {
          const key = localStorage.key(i);
          if (!key) continue;
          const lower = key.toLowerCase();
          if (lower.includes("depot") || lower.includes("surveybrain")) {
            keys.add(key);
          }
        }
      } catch (err) {
        console.warn("Could not enumerate localStorage keys during reset", err);
      }

      keys.forEach((key) => {
        try {
          localStorage.removeItem(key);
        } catch (err) {
          console.warn("Failed to remove localStorage key", key, err);
        }
      });

      try {
        sessionStorage.clear();
      } catch (err) {
        console.warn("Session storage could not be cleared", err);
      }
    }

    function sanitiseSectionSchema(input) {
      const asArray = (value) => {
        if (!value) return [];
        if (Array.isArray(value)) return value;
        if (value && typeof value === "object" && Array.isArray(value.sections)) {
          return value.sections;
        }
        return [];
      };

      const rawEntries = asArray(input);
      const prepared = [];
      rawEntries.forEach((entry, idx) => {
        if (!entry) return;
        const rawName = entry.name ?? entry.section ?? entry.title ?? entry.heading;
        const name = typeof rawName === "string" ? rawName.trim() : "";
        if (!name || name === "Arse_cover_notes") return;
        const rawDescription = entry.description ?? entry.hint ?? "";
        const description = typeof rawDescription === "string"
          ? rawDescription.trim()
          : String(rawDescription || "").trim();
        const order = typeof entry.order === "number" ? entry.order : idx + 1;
        prepared.push({ name, description, order, idx });
      });

      prepared.sort((a, b) => {
        const aHasOrder = typeof a.order === "number";
        const bHasOrder = typeof b.order === "number";
        if (aHasOrder && bHasOrder && a.order !== b.order) {
          return a.order - b.order;
        }
        if (aHasOrder && !bHasOrder) return -1;
        if (!aHasOrder && bHasOrder) return 1;
        return a.idx - b.idx;
      });

      const unique = [];
      const seen = new Set();
      prepared.forEach((entry) => {
        if (seen.has(entry.name)) return;
        seen.add(entry.name);
        unique.push({
          name: entry.name,
          description: entry.description || "",
          order: entry.order
        });
      });

      // Keep Future plans last, ensure it exists
      let withoutFuture = unique.filter((entry) => entry.name !== FUTURE_PLANS_NAME);
      let future = unique.find((entry) => entry.name === FUTURE_PLANS_NAME);
      if (!future) {
        future = {
          name: FUTURE_PLANS_NAME,
          description: "Notes about any future work or follow-on visits.",
          order: withoutFuture.length + 1
        };
      } else if (!future.description) {
        future = {
          ...future,
          description: "Notes about any future work or follow-on visits."
        };
      }

      const final = [...withoutFuture, future].map((entry, idx) => ({
        name: entry.name,
        description: entry.description || "",
        order: idx + 1
      }));

      return final;
    }

    function sanitiseChecklistConfig(value) {
      const asArray = (input) => {
        if (!input) return [];
        if (Array.isArray(input)) return input;
        if (input && typeof input === "object" && Array.isArray(input.items)) {
          return input.items;
        }
        return [];
      };

      const entries = asArray(value);
      const seen = new Set();
      const cleaned = [];

      entries.forEach((item) => {
        if (!item) return;
        const id = item.id != null ? String(item.id).trim() : "";
        const label = item.label != null ? String(item.label).trim() : "";
        if (!id || !label || seen.has(id)) return;
        seen.add(id);
        cleaned.push({
          id,
          group: (item.group || item.category || "Checklist").trim(),
          section: (item.section || item.sectionName || item.depotSection || "").trim(),
          label,
          hint: (item.hint || item.description || "").trim()
        });
      });

      return cleaned;
    }

    async function fetchJSON(path) {
      try {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) return null;
        return await res.json();
      } catch (_) {
        return null;
      }
    }

    // --- Section editor state / rendering ---
    const sectionsRowsEl = document.getElementById("sections-rows");
    const sectionsStatusEl = document.getElementById("sections-status");
    const sectionsCountPill = document.getElementById("sections-count-pill");
    const sectionRulesRowsEl = document.getElementById("section-rules-rows");
    const sectionRulesStatusEl = document.getElementById("section-rules-status");

    let sections = [];
    let sectionRules = {};

    function getDefaultSectionRules() {
      return {
        "Needs": "What the customer is asking for, priorities, budget, pain points, must-haves, and any red lines.",
        "Working at heights": "Safe access requirements for roofs, lofts, scaffolding, and working platforms.",
        "System characteristics": "Current heat source, system type, fuel, pipe sizes, hot water arrangement, and key locations.",
        "Components that require assistance": "Anything heavy or awkward that needs an extra person or special handling.",
        "Restrictions to work": "Timing, access windows, parking, permits, noisy hours, or rooms that are off limits.",
        "External hazards": "Asbestos, fragile roofs, pets, alarms, electrics, or other site-specific risks to flag early.",
        "Delivery notes": "Best drop-off point, contact name/number, site access codes, or parking instructions for deliveries.",
        "Office notes": "Administrative or pricing notes that planners need but do not belong in customer-facing sections.",
        "New boiler and controls": "Keep it simple: what appliance/controls are coming out, what is going in, which controls stay the same, which change, and where everything is being installed. Include cylinders, tanks, sealed system kits, and radiators if they are part of the job.",
        "Flue": "Route, termination type/position, lengths, terminals, clearances, plume kits, and any making good.",
        "Pipe work": "Upgrades, reroutes, sizes, isolation points, gas run details, and any dead legs being removed.",
        "Disruption": "Lifting floors, making good, decoration, access panels, and anything that will disturb finishes.",
        "Customer actions": "Tasks the customer must do before/after install: clearances, power, access, permissions, or paperwork.",
        "Future plans": "Follow-on work, phased upgrades, or extra visits to complete outstanding items."
      };
    }

    function renderSections() {
      sectionsRowsEl.innerHTML = "";
      if (!sections.length) {
        sectionsRowsEl.innerHTML = '<div class="row"><span class="order">–</span><div class="hint" style="grid-column: span 3;">No sections defined yet. Add your first section above.</div></div>';
        sectionsCountPill.textContent = "0 sections";
        return;
      }
      sectionsCountPill.textContent = sections.length + (sections.length === 1 ? " section" : " sections");

      sections.forEach((sec, idx) => {
        const row = document.createElement("div");
        row.className = "row";

        const orderSpan = document.createElement("span");
        orderSpan.className = "order";
        orderSpan.textContent = idx + 1;

        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = sec.name || "";
        nameInput.placeholder = "Section name";
        nameInput.oninput = () => {
          sections[idx].name = nameInput.value.trim();
        };

        const descInput = document.createElement("textarea");
        descInput.value = sec.description || "";
        descInput.placeholder = "Installer hint / description (optional)";
        descInput.oninput = () => {
          sections[idx].description = descInput.value.trim();
        };

        const controls = document.createElement("div");
        controls.className = "row-controls";

        const upBtn = document.createElement("button");
        upBtn.className = "small secondary";
        upBtn.textContent = "▲";
        upBtn.disabled = idx === 0;
        upBtn.onclick = () => {
          if (idx === 0) return;
          const tmp = sections[idx - 1];
          sections[idx - 1] = sections[idx];
          sections[idx] = tmp;
          renderSections();
        };

        const downBtn = document.createElement("button");
        downBtn.className = "small secondary";
        downBtn.textContent = "▼";
        downBtn.disabled = idx === sections.length - 1;
        downBtn.onclick = () => {
          if (idx === sections.length - 1) return;
          const tmp = sections[idx + 1];
          sections[idx + 1] = sections[idx];
          sections[idx] = tmp;
          renderSections();
        };

        const delBtn = document.createElement("button");
        delBtn.className = "small danger";
        delBtn.textContent = "✕";
        delBtn.onclick = () => {
          if (!confirm(`Remove section "${sec.name || "Untitled"}"?`)) return;
          sections.splice(idx, 1);
          renderSections();
        };

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(delBtn);

        row.appendChild(orderSpan);
        row.appendChild(nameInput);
        row.appendChild(descInput);
        row.appendChild(controls);
        sectionsRowsEl.appendChild(row);
      });

      renderSectionRules();
    }

    function renderSectionRules() {
      if (!sectionRulesRowsEl) return;

      sectionRulesRowsEl.innerHTML = "";
      const names = sections.length ? sections.map((sec) => sec.name) : Object.keys(sectionRules);

      if (!names.length) {
        sectionRulesRowsEl.innerHTML = '<div class="rule-row"><span class="hint">No sections available yet.</span></div>';
        sectionRulesStatusEl.textContent = "No section rules to show";
        return;
      }

        names.forEach((name) => {
          const row = document.createElement("div");
          row.className = "rule-row";

          const title = document.createElement("strong");
          title.textContent = name || "Untitled";

          const instructionsWrapper = document.createElement("div");
          instructionsWrapper.className = "rule-instructions";

          const instructionsLabel = document.createElement("span");
          instructionsLabel.className = "hint";
          instructionsLabel.textContent = "AI instructions for this section";

          const textarea = document.createElement("textarea");
          textarea.value = sectionRules[name] || "";
          textarea.placeholder = "Add guidance for what belongs in this section";
          textarea.oninput = () => {
            sectionRules[name] = textarea.value.trim();
          };

          instructionsWrapper.appendChild(instructionsLabel);
          instructionsWrapper.appendChild(textarea);

          row.appendChild(title);
          row.appendChild(instructionsWrapper);
          sectionRulesRowsEl.appendChild(row);
        });

      sectionRulesStatusEl.textContent = `Showing rules for ${names.length} section${names.length === 1 ? "" : "s"}.`;
    }

    async function loadSections() {
      sectionsStatusEl.textContent = "Loading sections…";
      let used = "defaults";

      // 1) Read overrides from localStorage (new key then legacy)
      const overrideNew = readJSONSafe(SECTION_STORAGE_KEY);
      const overrideLegacy = !overrideNew ? readJSONSafe(LEGACY_SECTION_STORAGE_KEY) : null;

      let local = overrideNew || overrideLegacy;
      let defaults = null;

      // 2) Fetch defaults from the bundled output schema
      defaults = await fetchJSON("depot.output.schema.json");

      const candidate = sanitiseSectionSchema(
        Array.isArray(local) && local.length ? local : defaults
      );

      sections = candidate;
      sectionsStatusEl.innerHTML = `Loaded <strong>${sections.length}</strong> sections (${overrideNew || overrideLegacy ? "from browser storage" : "from bundled schema file"}).`;
      renderSections();
    }

    function saveSectionsToLocal() {
      const cleaned = sanitiseSectionSchema(sections);
      // Store as { sections: [...] } for clarity
      const payload = { sections: cleaned };
      localStorage.setItem(SECTION_STORAGE_KEY, JSON.stringify(payload));
      sectionsStatusEl.innerHTML = `Saved <strong>${cleaned.length}</strong> sections to browser. Main app will pick these up on next load.`;
    }

    function exportSectionsJSON() {
      const cleaned = sanitiseSectionSchema(sections);
      const payload = { sections: cleaned };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `notes.sections.schema-${ts}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      sectionsStatusEl.innerHTML = `Exported <strong>${cleaned.length}</strong> sections as JSON file.`;
    }

    function importSectionsJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          const cleaned = sanitiseSectionSchema(data);
          sections = cleaned;
          localStorage.setItem(SECTION_STORAGE_KEY, JSON.stringify({ sections: cleaned }));
          renderSections();
          sectionsStatusEl.innerHTML = `Imported <strong>${cleaned.length}</strong> sections and saved to browser.`;
        } catch (err) {
          console.error(err);
          sectionsStatusEl.classList.add("error");
          sectionsStatusEl.innerHTML = `<strong>Error:</strong> Could not parse JSON file.`;
        }
      };
      reader.readAsText(file);
    }

    // --- Section rules state / rendering ---
    function loadSectionRules() {
      const defaults = getDefaultSectionRules();
      sectionRules = { ...defaults };

      try {
        const raw = localStorage.getItem(SECTION_RULES_STORAGE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
            sectionRules = { ...defaults, ...parsed };
          }
        }
      } catch (err) {
        console.warn("Failed to load section rules", err);
      }

      renderSectionRules();
      sectionRulesStatusEl.textContent = `Loaded rules for ${Object.keys(sectionRules).length} sections.`;
    }

    function saveSectionRules() {
      try {
        localStorage.setItem(SECTION_RULES_STORAGE_KEY, JSON.stringify(sectionRules));
        sectionRulesStatusEl.textContent = "Section rules saved to browser.";
      } catch (err) {
        alert("Unable to save section rules: " + (err?.message || err));
      }
    }

    function resetSectionRules() {
      sectionRules = getDefaultSectionRules();
      renderSectionRules();
      sectionRulesStatusEl.textContent = "Section rules reset to defaults.";
    }

    // --- Checklist editor state / rendering ---
    const checklistRowsEl = document.getElementById("checklist-rows");
    const checklistStatusEl = document.getElementById("checklist-status");
    const checklistCountPill = document.getElementById("checklist-count-pill");

    let checklist = [];

    function renderChecklistEditor() {
      checklistRowsEl.innerHTML = "";
      if (!checklist.length) {
        checklistRowsEl.innerHTML = '<div class="checklist-row"><span class="order">–</span><div class="hint" style="grid-column: span 5;">No checklist items yet. Add your first item above.</div></div>';
        checklistCountPill.textContent = "0 items";
        return;
      }
      checklistCountPill.textContent = checklist.length + (checklist.length === 1 ? " item" : " items");

      checklist.forEach((item, idx) => {
        const row = document.createElement("div");
        row.className = "checklist-row";

        const orderSpan = document.createElement("span");
        orderSpan.className = "order";
        orderSpan.textContent = idx + 1;

        const idInput = document.createElement("input");
        idInput.type = "text";
        idInput.value = item.id || "";
        idInput.placeholder = "ID (stable)";
        idInput.oninput = () => {
          checklist[idx].id = idInput.value.trim();
        };

        const groupInput = document.createElement("input");
        groupInput.type = "text";
        groupInput.value = item.group || "";
        groupInput.placeholder = "Group (e.g. Boiler & controls)";
        groupInput.oninput = () => {
          checklist[idx].group = groupInput.value.trim();
        };

        const sectionInput = document.createElement("input");
        sectionInput.type = "text";
        sectionInput.value = item.section || "";
        sectionInput.placeholder = "Section link (optional)";
        sectionInput.oninput = () => {
          checklist[idx].section = sectionInput.value.trim();
        };

        const labelInput = document.createElement("input");
        labelInput.type = "text";
        labelInput.value = item.label || "";
        labelInput.placeholder = "Question / label";
        labelInput.oninput = () => {
          checklist[idx].label = labelInput.value.trim();
        };

        const hintInput = document.createElement("input");
        hintInput.type = "text";
        hintInput.value = item.hint || "";
        hintInput.placeholder = "Hint (optional)";
        hintInput.oninput = () => {
          checklist[idx].hint = hintInput.value.trim();
        };

        // Expand button to show plainText and naturalLanguage
        const expandBtn = document.createElement("button");
        expandBtn.className = "small secondary";
        expandBtn.textContent = "⋯";
        expandBtn.title = "Show/hide AI templates";
        expandBtn.style.fontSize = "1.2rem";
        expandBtn.style.padding = "2px 8px";

        const controls = document.createElement("div");
        controls.className = "row-controls";

        const upBtn = document.createElement("button");
        upBtn.className = "small secondary";
        upBtn.textContent = "▲";
        upBtn.disabled = idx === 0;
        upBtn.onclick = () => {
          if (idx === 0) return;
          const tmp = checklist[idx - 1];
          checklist[idx - 1] = checklist[idx];
          checklist[idx] = tmp;
          renderChecklistEditor();
        };

        const downBtn = document.createElement("button");
        downBtn.className = "small secondary";
        downBtn.textContent = "▼";
        downBtn.disabled = idx === checklist.length - 1;
        downBtn.onclick = () => {
          if (idx === checklist.length - 1) return;
          const tmp = checklist[idx + 1];
          checklist[idx + 1] = checklist[idx];
          checklist[idx] = tmp;
          renderChecklistEditor();
        };

        const delBtn = document.createElement("button");
        delBtn.className = "small danger";
        delBtn.textContent = "✕";
        delBtn.onclick = () => {
          if (!confirm(`Remove checklist item "${item.label || item.id || "Untitled"}"?`)) return;
          checklist.splice(idx, 1);
          renderChecklistEditor();
        };

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(delBtn);

        // Expandable section for AI templates
        const expandableSection = document.createElement("div");
        expandableSection.style.gridColumn = "1 / -1";
        expandableSection.style.display = "none";
        expandableSection.style.padding = "12px";
        expandableSection.style.background = "#f8fafc";
        expandableSection.style.borderRadius = "8px";
        expandableSection.style.marginTop = "8px";

        const templatesLabel = document.createElement("div");
        templatesLabel.style.fontSize = "0.75rem";
        templatesLabel.style.fontWeight = "600";
        templatesLabel.style.marginBottom = "8px";
        templatesLabel.textContent = "AI Templates (used by worker to generate section content)";

        const plainTextLabel = document.createElement("label");
        plainTextLabel.style.display = "block";
        plainTextLabel.style.fontSize = "0.7rem";
        plainTextLabel.style.marginTop = "8px";
        plainTextLabel.style.marginBottom = "4px";
        plainTextLabel.textContent = "Plain Text Template (bullet points):";

        const plainTextArea = document.createElement("textarea");
        plainTextArea.value = item.plainText || "";
        plainTextArea.placeholder = "Bullet-point style template for plainText...";
        plainTextArea.rows = 3;
        plainTextArea.style.width = "100%";
        plainTextArea.style.fontFamily = "monospace";
        plainTextArea.style.fontSize = "0.7rem";
        plainTextArea.style.padding = "8px";
        plainTextArea.style.border = "1px solid #d4dbe5";
        plainTextArea.style.borderRadius = "6px";
        plainTextArea.oninput = () => {
          checklist[idx].plainText = plainTextArea.value;
        };

        const naturalLanguageLabel = document.createElement("label");
        naturalLanguageLabel.style.display = "block";
        naturalLanguageLabel.style.fontSize = "0.7rem";
        naturalLanguageLabel.style.marginTop = "8px";
        naturalLanguageLabel.style.marginBottom = "4px";
        naturalLanguageLabel.textContent = "Natural Language Template (prose):";

        const naturalLanguageArea = document.createElement("textarea");
        naturalLanguageArea.value = item.naturalLanguage || "";
        naturalLanguageArea.placeholder = "Prose description template for naturalLanguage...";
        naturalLanguageArea.rows = 3;
        naturalLanguageArea.style.width = "100%";
        naturalLanguageArea.style.fontFamily = "monospace";
        naturalLanguageArea.style.fontSize = "0.7rem";
        naturalLanguageArea.style.padding = "8px";
        naturalLanguageArea.style.border = "1px solid #d4dbe5";
        naturalLanguageArea.style.borderRadius = "6px";
        naturalLanguageArea.oninput = () => {
          checklist[idx].naturalLanguage = naturalLanguageArea.value;
        };

        expandableSection.appendChild(templatesLabel);
        expandableSection.appendChild(plainTextLabel);
        expandableSection.appendChild(plainTextArea);
        expandableSection.appendChild(naturalLanguageLabel);
        expandableSection.appendChild(naturalLanguageArea);

        // Toggle expand button
        expandBtn.onclick = () => {
          const isHidden = expandableSection.style.display === "none";
          expandableSection.style.display = isHidden ? "block" : "none";
          expandBtn.textContent = isHidden ? "−" : "⋯";
        };

        row.appendChild(orderSpan);
        row.appendChild(idInput);
        row.appendChild(groupInput);
        row.appendChild(sectionInput);
        row.appendChild(labelInput);
        row.appendChild(hintInput);
        row.appendChild(expandBtn);
        row.appendChild(controls);
        row.appendChild(expandableSection);

        checklistRowsEl.appendChild(row);
      });
    }

    async function loadChecklist() {
      checklistStatusEl.textContent = "Loading checklist…";

      const override = sanitiseChecklistConfig(readJSONSafe(CHECKLIST_STORAGE_KEY));
      const defaultsRaw = await fetchJSON("checklist.config.json");
      const defaults = sanitiseChecklistConfig(defaultsRaw);

      const candidate = override.length ? override : defaults;
      checklist = candidate;

      const source = override.length ? "browser storage" : "checklist.config.json";
      checklistStatusEl.innerHTML = `Loaded <strong>${checklist.length}</strong> items (${source}).`;
      renderChecklistEditor();
    }

    function saveChecklistToLocal() {
      const cleaned = sanitiseChecklistConfig(checklist);
      const payload = { items: cleaned };
      localStorage.setItem(CHECKLIST_STORAGE_KEY, JSON.stringify(payload));
      checklistStatusEl.innerHTML = `Saved <strong>${cleaned.length}</strong> checklist items to browser.`;
    }

    function exportChecklistJSON() {
      const cleaned = sanitiseChecklistConfig(checklist);
      const payload = { items: cleaned };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `notes.checklist-${ts}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      checklistStatusEl.innerHTML = `Exported <strong>${cleaned.length}</strong> checklist items as JSON file.`;
    }

    function importChecklistJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          const cleaned = sanitiseChecklistConfig(data);
          checklist = cleaned;
          localStorage.setItem(CHECKLIST_STORAGE_KEY, JSON.stringify({ items: cleaned }));
          renderChecklistEditor();
          checklistStatusEl.innerHTML = `Imported <strong>${cleaned.length}</strong> checklist items and saved to browser.`;
        } catch (err) {
          console.error(err);
          checklistStatusEl.classList.add("error");
          checklistStatusEl.innerHTML = `<strong>Error:</strong> Could not parse JSON file.`;
        }
      };
      reader.readAsText(file);
    }

    // --- Wire up buttons ---
    const forceReloadBtn = document.getElementById("forceReloadBtn");
    if (forceReloadBtn) {
      forceReloadBtn.addEventListener("click", () => {
        const confirmReset = confirm("This will clear all stored Survey Brain data on this device. Continue?");
        if (!confirmReset) return;
        const originalLabel = forceReloadBtn.textContent;
        forceReloadBtn.disabled = true;
        forceReloadBtn.textContent = "Resetting…";
        try {
          clearStoredAppData();
          window.location.replace("index.html");
        } catch (err) {
          console.error("Force reload/reset failed", err);
          alert("Failed to reset stored data. Please hard refresh the page.");
          forceReloadBtn.disabled = false;
          forceReloadBtn.textContent = originalLabel;
        }
      });
    }

    document.getElementById("sections-add-btn").onclick = () => {
      sections.push({
        name: "",
        description: "",
        order: sections.length + 1
      });
      renderSections();
    };
    document.getElementById("sections-save-btn").onclick = saveSectionsToLocal;
    document.getElementById("sections-export-btn").onclick = exportSectionsJSON;
    document.getElementById("sections-import-btn").onclick = () => {
      document.getElementById("sections-import-input").click();
    };
    document.getElementById("sections-import-input").onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      importSectionsJSON(file);
      e.target.value = "";
    };

    document.getElementById("section-rules-save-btn")?.addEventListener("click", saveSectionRules);
    document.getElementById("section-rules-reset-btn")?.addEventListener("click", resetSectionRules);

    document.getElementById("checklist-add-btn").onclick = () => {
      checklist.push({
        id: "",
        group: "Checklist",
        section: "",
        label: "",
        hint: ""
      });
      renderChecklistEditor();
    };
    document.getElementById("checklist-save-btn").onclick = saveChecklistToLocal;
    document.getElementById("checklist-export-btn").onclick = exportChecklistJSON;
    document.getElementById("checklist-import-btn").onclick = () => {
      document.getElementById("checklist-import-input").click();
    };
    document.getElementById("checklist-import-input").onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      importChecklistJSON(file);
      e.target.value = "";
    };

    // --- Export Format Preferences ---
    function loadExportFormat() {
      const format = localStorage.getItem('exportFormat') || 'json';
      const radioBtn = document.getElementById(format === 'csv' ? 'formatCSV' : 'formatJSON');
      if (radioBtn) radioBtn.checked = true;
    }

    function saveExportFormat(format) {
      localStorage.setItem('exportFormat', format);
    }

    document.querySelectorAll('input[name="exportFormat"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        saveExportFormat(e.target.value);
      });
    });

    // --- AI Instructions ---
    function getDefaultAIInstructions() {
      return {
        agentChat: `You are an AI assistant helping with heating survey work for a British Gas style boiler installation surveyor.

You have access to:
- The current survey sections and notes
- The transcript of conversations
- Reference materials from the knowledge database

Your job is to:
1. Answer questions about the survey, products, pricing, or technical details
2. Provide helpful suggestions based on the context
3. Help fill in missing information
4. Be concise but accurate

SANITY CHECKING:
- Actively correct obvious transcription mistakes using the context provided (e.g., if a pipe size looks wrong, normalise it to the nearest standard size).
- Standard pipework sizes are 8/10mm (microbore), 15mm, 22mm, 28mm, and 35mm—prefer these when resolving ambiguities.
- Prefer the most recent reference material versions (e.g., the latest pricebook such as November 2025) when multiple versions exist.

IMPORTANT:
- Use the reference materials to provide accurate product specifications and pricing
- If you don't know something, say so
- Keep responses brief and actionable
- Focus on helping complete the survey accurately`,
        tweakSection: `You are an expert heating survey assistant helping to improve survey notes.

You will receive:
- A section name (e.g., "Needs", "New boiler and controls")
- Current plainText (bullet-point style, semicolon-separated)
- Current naturalLanguage (prose description)
- User instructions on how to improve the section

Your job is to:
1. Read the current section content carefully
2. Apply the user's improvement instructions
3. Return an improved version of the section that maintains the same format

IMPORTANT RULES:
- Keep the same section name
- Maintain the plainText format (semicolon-separated bullet points)
- Maintain the naturalLanguage format (clear prose)
- Apply the user's instructions precisely
- Only modify what the user asks to improve
- Keep the technical accuracy and detail level
- Do not add information that wasn't requested
- Correct any obvious transcription errors using the context provided, especially standard pipe sizes (8/10mm, 15mm, 22mm, 28mm, 35mm) and other common measurements. Normalise improbable values to the nearest sensible standard size.

You MUST respond with ONLY valid JSON matching this shape:

{
  "section": "[section name]",
  "plainText": "Improved bullet points; separated by semicolons;",
  "naturalLanguage": "Improved prose description."
}

Do not wrap the JSON in backticks or markdown.
Do not include any explanation outside the JSON.`
        ,
        depotNotes: DEFAULT_NOTES_INSTRUCTIONS
      };
    }

    function loadAIInstructions() {
      const defaults = getDefaultAIInstructions();
      try {
        const raw = localStorage.getItem(AI_INSTRUCTIONS_STORAGE_KEY);
        if (raw) {
          const stored = JSON.parse(raw);
          return {
            agentChat: stored.agentChat || defaults.agentChat,
            tweakSection: stored.tweakSection || defaults.tweakSection,
            depotNotes: stored.depotNotes || defaults.depotNotes
          };
        }
      } catch (err) {
        console.warn("Failed to read AI instructions override", err);
      }
      return defaults;
    }

    function saveAIInstructions(instructions) {
      try {
        localStorage.setItem(AI_INSTRUCTIONS_STORAGE_KEY, JSON.stringify(instructions));
        document.getElementById('ai-status').textContent = "AI instructions saved successfully";
        setTimeout(() => {
          document.getElementById('ai-status').textContent = "";
        }, 3000);
      } catch (err) {
        alert("Unable to save AI instructions: " + (err?.message || err));
      }
    }

    function renderAIInstructions() {
      const instructions = loadAIInstructions();
      const agentChatArea = document.getElementById('ai-agent-chat-instructions');
      const tweakSectionArea = document.getElementById('ai-tweak-section-instructions');
      const depotNotesArea = document.getElementById('notes-instructions');

      if (agentChatArea) {
        agentChatArea.value = instructions.agentChat;
      }
      if (tweakSectionArea) {
        tweakSectionArea.value = instructions.tweakSection;
      }
      if (depotNotesArea) {
        depotNotesArea.value = instructions.depotNotes;
      }
    }

    // AI Instructions event listeners
    document.getElementById('ai-save-btn')?.addEventListener('click', () => {
      const agentChatArea = document.getElementById('ai-agent-chat-instructions');
      const tweakSectionArea = document.getElementById('ai-tweak-section-instructions');
      const depotNotesArea = document.getElementById('notes-instructions');

      const instructions = {
        agentChat: agentChatArea?.value || getDefaultAIInstructions().agentChat,
        tweakSection: tweakSectionArea?.value || getDefaultAIInstructions().tweakSection,
        depotNotes: depotNotesArea?.value || getDefaultAIInstructions().depotNotes
      };

      saveAIInstructions(instructions);
    });

    document.getElementById('ai-reset-btn')?.addEventListener('click', () => {
      if (!confirm('Reset AI instructions to defaults? This cannot be undone.')) return;

      localStorage.removeItem(AI_INSTRUCTIONS_STORAGE_KEY);
      renderAIInstructions();
      document.getElementById('ai-status').textContent = "AI instructions reset to defaults";
      setTimeout(() => {
        document.getElementById('ai-status').textContent = "";
      }, 3000);
    });

    document.getElementById('notes-reset-btn')?.addEventListener('click', () => {
      const depotNotesArea = document.getElementById('notes-instructions');
      if (depotNotesArea) {
        depotNotesArea.value = getDefaultAIInstructions().depotNotes;
        document.getElementById('ai-status').textContent = "Notes instructions reset to recommended rules";
        setTimeout(() => {
          document.getElementById('ai-status').textContent = "";
        }, 3000);
      }
    });

    // --- Authentication and Cloud Sync ---
    async function updateAuthUI() {
      const loginBtn = document.getElementById('loginBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const userDisplay = document.getElementById('userDisplay');
      const syncToCloudBtn = document.getElementById('syncToCloudBtn');
      const syncFromCloudBtn = document.getElementById('syncFromCloudBtn');

      // Check if auth module is loaded
      if (typeof window.DepotAuth === 'undefined') {
        console.warn('DepotAuth module not loaded yet');
        return;
      }

      const isAuth = window.DepotAuth.isAuthenticated();

      if (isAuth) {
        const userInfo = window.DepotAuth.getUserInfo();
        if (userInfo) {
          userDisplay.textContent = `Signed in as ${userInfo.username}`;
          loginBtn.style.display = 'none';
          logoutBtn.style.display = 'inline-flex';
          syncToCloudBtn.disabled = false;
          syncFromCloudBtn.disabled = false;
        }
      } else {
        userDisplay.textContent = 'Not signed in';
        loginBtn.style.display = 'inline-flex';
        logoutBtn.style.display = 'none';
        syncToCloudBtn.disabled = true;
        syncFromCloudBtn.disabled = true;
      }
    }

    document.getElementById('loginBtn')?.addEventListener('click', () => {
      window.location.href = 'login.html';
    });

    document.getElementById('logoutBtn')?.addEventListener('click', () => {
      if (confirm('Sign out? Your local settings will remain on this device.')) {
        if (typeof window.DepotAuth !== 'undefined') {
          window.DepotAuth.logout();
        }
      }
    });

    document.getElementById('syncToCloudBtn')?.addEventListener('click', async () => {
      if (typeof window.DepotAuth === 'undefined') {
        alert('Authentication module not loaded');
        return;
      }

      if (!window.DepotAuth.isAuthenticated()) {
        alert('Please sign in first');
        window.location.href = 'login.html';
        return;
      }

      const btn = document.getElementById('syncToCloudBtn');
      const status = document.getElementById('syncStatus');

      btn.disabled = true;
      btn.textContent = 'Syncing...';
      status.textContent = 'Uploading settings to cloud...';

      const result = await window.DepotAuth.syncAllSettingsToCloud();

      btn.disabled = false;
      btn.textContent = '↑ Save to Cloud';

      if (result.success) {
        status.innerHTML = `<strong>Success!</strong> Saved ${result.saved} settings to cloud.`;
        status.classList.remove('error');
      } else {
        status.innerHTML = `<strong>Error:</strong> ${result.error}`;
        status.classList.add('error');
      }

      setTimeout(() => {
        status.textContent = '';
        status.classList.remove('error');
      }, 5000);
    });

    document.getElementById('syncFromCloudBtn')?.addEventListener('click', async () => {
      if (typeof window.DepotAuth === 'undefined') {
        alert('Authentication module not loaded');
        return;
      }

      if (!window.DepotAuth.isAuthenticated()) {
        alert('Please sign in first');
        window.location.href = 'login.html';
        return;
      }

      if (!confirm('Load settings from cloud? This will overwrite your current local settings.')) {
        return;
      }

      const btn = document.getElementById('syncFromCloudBtn');
      const status = document.getElementById('syncStatus');

      btn.disabled = true;
      btn.textContent = 'Syncing...';
      status.textContent = 'Downloading settings from cloud...';

      const result = await window.DepotAuth.syncAllSettingsFromCloud();

      btn.disabled = false;
      btn.textContent = '↓ Load from Cloud';

      if (result.success) {
        status.innerHTML = `<strong>Success!</strong> Loaded ${result.appliedCount} settings from cloud. <a href="#" onclick="location.reload()">Reload page</a> to see changes.`;
        status.classList.remove('error');
      } else {
        status.innerHTML = `<strong>Error:</strong> ${result.error}`;
        status.classList.add('error');
      }
    });

    // --- Boot ---
    (async function boot() {
      await loadSections();
      loadSectionRules();
      await loadChecklist();
      loadExportFormat();
      renderAIInstructions();

      // Load auth module dynamically
      try {
        await import('./src/auth/auth-client.js');
        updateAuthUI();
      } catch (err) {
        console.warn('Failed to load auth module:', err);
      }
    })();
  </script>
</body>
</html>
