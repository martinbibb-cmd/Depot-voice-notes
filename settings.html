<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Survey Brain ‚Äì Settings</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script type="module" src="./js/themeSettings.js"></script>
  <script>
    (function () {
      const key = "depot.themePreference";
      const saved = localStorage.getItem(key);
      const validThemes = ["blue", "green"];
      const theme = validThemes.includes(saved) ? saved : "blue";
      document.documentElement.dataset.theme = theme;
    })();
  </script>
  <style>
    :root {
      /* Silver control deck theme (matches main app) */
      --bg: #e7eaef;
      --card: linear-gradient(145deg, #f4f6f8 0%, #dde2e7 50%, #f4f6f8 100%);
      --border: #b5bcc7;
      --accent: #2563eb;
      --accent-hover: #1d4ed8;
      --accent-soft: #dbeafe;
      --muted: #4b5563;
      --danger: #d14343;
      --radius: 6px;
      --screen-glow: 0 0 12px rgba(37, 99, 235, 0.35);
      --metal-shine: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.35) 50%, rgba(255,255,255,0) 100%);
      --button-inset: inset 1px 1px 3px rgba(255,255,255,0.65), inset -3px -3px 6px rgba(0,0,0,0.08);
      --screen-bg: linear-gradient(180deg, #eef2f7 0%, #d8dee6 100%);
      --text: #1f2937;
    }

    :root[data-theme="green"] {
      --accent: #2f855a;
      --accent-hover: #276749;
      --accent-soft: #c9e4d4;
      --screen-glow: 0 0 12px rgba(79, 209, 197, 0.35);
    }
    * { box-sizing: border-box; }

    @keyframes screenFlicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.98; }
    }

    @keyframes ledPulse {
      0%, 100% { box-shadow: 0 0 5px currentColor, 0 0 10px currentColor; }
      50% { box-shadow: 0 0 10px currentColor, 0 0 20px currentColor; }
    }

    @keyframes metalShimmer {
      0% { background-position: -200% center; }
      100% { background-position: 200% center; }
    }

    body {
      margin: 0;
      font-family: 'Inter', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      background:
        linear-gradient(180deg, #f8fafc 0%, #e1e6ee 40%, #d4d9e1 100%);
      color: var(--text);
      min-height: 100vh;
      padding: 16px;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        repeating-linear-gradient(90deg, transparent 0px, rgba(255,255,255,0.25) 2px, transparent 4px),
        repeating-linear-gradient(0deg, transparent 0px, rgba(0,0,0,0.04) 2px, transparent 4px);
      background-size: 4px 4px;
      pointer-events: none;
      z-index: 1;
      animation: screenFlicker 3s infinite;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 16px;
      padding: 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--button-inset), 0 6px 12px rgba(0,0,0,0.08);
      position: relative;
      z-index: 2;
    }

    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      animation: metalShimmer 3s linear infinite;
      background-size: 200% 100%;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
      text-shadow: 0 0 6px var(--accent);
      font-weight: 700;
    }

    header span {
      font-size: .75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    a.back-link {
      margin-left: auto;
      font-size: .8rem;
      color: #7dd3fc;
      text-decoration: none;
    }
    a.back-link:hover {
      text-decoration: underline;
    }
    main {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 14px;
      position: relative;
      z-index: 2;
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 16px 18px 18px;
      color: var(--text);
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: var(--button-inset), 0 10px 18px rgba(0,0,0,0.12);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(16, 185, 129, 0.5), transparent);
    }

    .card::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--metal-shine);
      background-size: 200% 100%;
      opacity: 0.05;
      pointer-events: none;
    }
    .card-header {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .card-header h2 {
      margin: 0;
      font-size: .9rem;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--accent);
      text-shadow: 0 0 5px var(--accent);
      font-weight: 700;
    }
    .card-header span {
      font-size: .7rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 4px;
    }
    button {
      border: 2px solid var(--border);
      border-radius: var(--radius);
      padding: 8px 16px;
      font-size: .7rem;
      font-weight: 700;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(145deg, var(--accent) 0%, var(--accent-hover, #1d4ed8) 100%);
      color: #fff;
      white-space: nowrap;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2), inset 0 -1px 0 rgba(0,0,0,0.3);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
      font-family: 'Courier New', 'Consolas', monospace;
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      transform: translate(-50%, -50%);
      transition: width 0.3s, height 0.3s;
    }

    button:hover:not(:disabled)::before {
      width: 300px;
      height: 300px;
    }

    button:hover:not(:disabled) {
      background: linear-gradient(145deg, var(--accent-soft) 0%, var(--accent) 100%);
      box-shadow: 0 4px 8px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.3), inset 0 -1px 0 rgba(0,0,0,0.16);
    }

    button:active:not(:disabled) {
      box-shadow: var(--button-inset);
      transform: translateY(1px);
    }

    button.secondary {
      background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 100%);
      color: var(--text);
    }

    button.secondary:hover:not(:disabled) {
      background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 100%);
    }

    button.danger {
      background: linear-gradient(145deg, var(--danger) 0%, #dc2626 100%);
      color: white;
    }

    button.danger:hover:not(:disabled) {
      background: linear-gradient(145deg, #f87171 0%, var(--danger) 100%);
    }

    button.small {
      padding: 4px 10px;
      font-size: .65rem;
      font-weight: 600;
    }

    button:disabled {
      opacity: .4;
      cursor: not-allowed;
      background: linear-gradient(145deg, #e5e7eb 0%, #d1d5db 100%);
      color: #6b7280;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: .65rem;
      border-radius: var(--radius);
      padding: 4px 10px;
      background: linear-gradient(145deg, #eef2f7 0%, #e2e8f0 100%);
      color: var(--accent);
      border: 1px solid var(--border);
      box-shadow: inset 1px 1px 2px rgba(0,0,0,0.4);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 600;
    }
    .pill.small {
      font-size: .6rem;
      padding: 3px 8px;
    }
    .pill-tag {
      background: linear-gradient(145deg, #eef2f7 0%, #e2e8f0 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 3px 8px;
      font-size: .6rem;
      color: var(--accent);
      box-shadow: inset 1px 1px 2px rgba(255,255,255,0.6);
    }
    .rows {
      border-radius: var(--radius);
      border: 1px solid var(--border);
      max-height: 60vh;
      overflow: auto;
      background: var(--screen-bg);
      box-shadow: inset 2px 2px 6px rgba(0,0,0,0.06);
    }
    .row {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) minmax(0, 2fr) auto;
      gap: 6px;
      padding: 8px 10px;
      align-items: flex-start;
      border-bottom: 1px solid rgba(74, 85, 104, 0.3);
    }
    .row:last-child {
      border-bottom: none;
    }
    .row span.order {
      font-size: .65rem;
      color: var(--accent);
      min-width: 2rem;
      font-weight: 700;
      text-shadow: 0 0 5px var(--accent);
    }
    .row input[type="text"] {
      width: 100%;
      font-size: .7rem;
      padding: 6px 8px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(145deg, #f8fafc 0%, #e5e9ef 100%);
      color: var(--text);
      font-family: 'Inter', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.08);
    }

    .row input[type="text"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.08), 0 0 8px rgba(37, 99, 235, 0.25);
    }

    .row textarea {
      width: 100%;
      font-size: .7rem;
      padding: 6px 8px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(145deg, #f8fafc 0%, #e5e9ef 100%);
      color: var(--text);
      font-family: 'Inter', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      resize: vertical;
      min-height: 42px;
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.08);
    }

    .row textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5), 0 0 8px rgba(16, 185, 129, 0.4);
    }
    .row-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .checklist-rows {
      border-radius: 12px;
      border: 1px solid var(--border);
      max-height: 60vh;
      overflow: auto;
      background: #f8fafc;
    }
    .checklist-row {
      display: grid;
      grid-template-columns: auto minmax(0, 0.9fr) minmax(0, 1fr) minmax(0, 1.4fr) minmax(0, 2fr) minmax(0, 1fr) auto auto;
      gap: 4px;
      padding: 6px 8px;
      align-items: flex-start;
      border-bottom: 1px solid #e2e8f0;
    }
    .checklist-row:last-child {
      border-bottom: none;
    }
    .checklist-row span.order {
      font-size: .65rem;
      color: var(--muted);
      min-width: 1.5rem;
    }
    .checklist-row input[type="text"],
    .checklist-row select {
      width: 100%;
      font-size: .65rem;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      background: #fff;
    }
    .status {
      font-size: .65rem;
      color: var(--muted);
      margin-top: 4px;
      font-family: 'Courier New', 'Consolas', monospace;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .status strong {
      color: var(--accent);
      text-shadow: 0 0 5px var(--accent);
    }
    .status.error strong {
      color: var(--danger);
      text-shadow: 0 0 5px var(--danger);
    }
    .hint {
      font-size: .65rem;
      color: var(--muted);
      font-family: 'Courier New', 'Consolas', monospace;
      line-height: 1.4;
    }
    .rule-rows {
      border-radius: 12px;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      max-height: 50vh;
      overflow: auto;
    }
    .rule-row {
      display: grid;
      grid-template-columns: minmax(0, 0.4fr) minmax(0, 1.6fr);
      gap: 8px;
      padding: 8px 10px;
      align-items: start;
      border-bottom: 1px solid #e2e8f0;
    }
    .rule-row:last-child {
      border-bottom: none;
    }
    .rule-row strong {
      font-size: .75rem;
      color: var(--text);
    }
    .rule-row textarea {
      width: 100%;
      font-size: .7rem;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      resize: vertical;
      min-height: 72px;
    }
    .rule-instructions {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .rule-instructions .hint {
      margin: 0;
    }
  </style>

  <script>
    window.DepotBuildInfo = {
      appVersion: '1.2.0',
      cacheVersion: 'depot-v1.2.0'
    };
  </script>

  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">

  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#2563eb">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Depot Notes">

  <!-- Icons -->
  <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="/icon-512.png">
  <link rel="apple-touch-icon" href="/icon-192.png">
</head>
<body>
  <header>
    <h1>Survey Brain Settings</h1>
    <span>Section schema & checklist config</span>
    <div id="authStatus" style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
      <span id="userDisplay" style="font-size: 0.75rem; color: #7dd3fc;"></span>
      <button id="loginBtn" class="secondary" style="font-size: 0.7rem; padding: 4px 10px;">Sign In</button>
      <button id="logoutBtn" class="secondary" style="font-size: 0.7rem; padding: 4px 10px; display: none;">Sign Out</button>
    </div>
    <button id="openSetupWizardBtn" style="background: linear-gradient(145deg, #10b981 0%, #059669 100%);">üßô‚Äç‚ôÇÔ∏è Setup Wizard</button>
    <button id="forceReloadBtn" class="danger">Force reload / reset app data</button>
    <a href="index.html" class="back-link">‚Üê Back to app</a>
  </header>

  <main>
    <!-- Cloud Sync Section -->
    <section class="card" style="grid-column: 1 / -1;" id="cloudSyncSection">
      <div class="card-header">
        <h2>Cloud Sync</h2>
        <span>Sync settings across devices</span>
      </div>

      <div class="toolbar">
        <button id="syncToCloudBtn" class="secondary">‚Üë Save to Cloud</button>
        <button id="syncFromCloudBtn" class="secondary">‚Üì Load from Cloud</button>
      </div>

      <p class="hint">
        Sign in to sync your settings, sections, checklist, and AI instructions across all your devices.
        Your data is securely stored and only accessible with your account.
      </p>

      <p class="status" id="syncStatus"></p>
    </section>

    <!-- Build / Variation info -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Build & Variation Numbers</h2>
        <span>Identify the exact version currently loaded</span>
      </div>

      <div class="rows">
        <div class="row">
          <span class="order">#1</span>
          <div>
            <strong>App variation</strong>
            <div class="hint">Tracks the main build/version number for this release.</div>
          </div>
          <div>
            <span class="pill" id="appVariationValue">Loading‚Ä¶</span>
          </div>
          <div class="row-controls"></div>
        </div>

        <div class="row">
          <span class="order">#2</span>
          <div>
            <strong>Cache variation</strong>
            <div class="hint">Matches the service worker cache key to confirm updates shipped.</div>
          </div>
          <div>
            <span class="pill" id="cacheVariationValue">Loading‚Ä¶</span>
          </div>
          <div class="row-controls"></div>
        </div>

        <div class="row">
          <span class="order">#3</span>
          <div>
            <strong>Worker endpoint in use</strong>
            <div class="hint">Confirms which backend is receiving cloud saves and updates.</div>
          </div>
          <div>
            <span class="pill" id="workerEndpointValue">Loading‚Ä¶</span>
          </div>
          <div class="row-controls"></div>
        </div>
      </div>
    </section>

    <!-- PWA & Updates Section -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>App Updates & Installation</h2>
        <span>Manage PWA features and updates</span>
      </div>

      <div class="toolbar">
        <button id="checkUpdatesBtn" class="secondary">üîÑ Check for Updates</button>
        <button id="installAppBtn" class="secondary" style="display: none;">üì± Install App</button>
        <button id="clearCacheBtn" class="secondary">üßπ Clear Cache</button>
      </div>

      <p class="hint">
        <strong>Check for Updates:</strong> Manually check if a new version of the app is available.<br>
        <strong>Install App:</strong> Install Depot Voice Notes as a standalone app on your device (available when supported).<br>
        <strong>Clear Cache:</strong> Clear cached files to free up space or resolve issues.
      </p>

      <div id="pwaStatus" style="margin-top: 12px; padding: 10px; background: var(--screen-bg); border-radius: var(--radius); font-size: 0.75rem; color: var(--muted);">
        Service Worker: <span id="swStatus">Checking...</span>
      </div>
    </section>

    <!-- Export Format Preferences -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Export Format</h2>
        <span>Choose default file format for exports</span>
      </div>
      <div style="display: flex; gap: 12px; align-items: center;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="radio" name="exportFormat" value="json" id="formatJSON" checked>
          <span style="font-size: 0.75rem; font-weight: 600;">JSON (default)</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="radio" name="exportFormat" value="csv" id="formatCSV">
          <span style="font-size: 0.75rem; font-weight: 600;">CSV (Comma-Separated Values)</span>
        </label>
      </div>
      <p class="hint">
        This setting controls the format used when exporting notes, sessions, and automatic/AI notes.
        JSON exports include all data in a structured format, while CSV exports are optimized for spreadsheet applications.
      </p>
    </section>

    <!-- Voice Notes 2.0 Settings -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Voice Notes 2.0 Features</h2>
        <span>Configure new Voice Notes 2.0 features</span>
      </div>

      <div style="display: flex; flex-direction: column; gap: 16px;">
        <div style="padding: 12px; background: var(--screen-bg); border-radius: var(--radius); border: 1px solid var(--border);">
          <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
            <input type="checkbox" id="skipClarificationModal" style="cursor: pointer; width: 18px; height: 18px;">
            <div>
              <span style="font-size: 0.75rem; font-weight: 600; display: block;">Skip Clarification Modal</span>
              <span class="hint" style="display: block; margin-top: 4px;">When enabled, the pre-processing clarification modal will be skipped and notes will generate immediately.</span>
            </div>
          </label>
        </div>

        <div style="padding: 12px; background: var(--screen-bg); border-radius: var(--radius); border: 1px solid var(--border);">
          <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
            <input type="checkbox" id="enableMultipleQuotesDetection" checked style="cursor: pointer; width: 18px; height: 18px;">
            <div>
              <span style="font-size: 0.75rem; font-weight: 600; display: block;">Auto-detect Multiple Quotes</span>
              <span class="hint" style="display: block; margin-top: 4px;">Automatically detect when the transcript discusses multiple quote options and generate separate quote variants.</span>
            </div>
          </label>
        </div>
      </div>

      <p class="hint" style="margin-top: 12px;">
        <strong>New in Voice Notes 2.0:</strong> Pre-processing clarification modal helps prevent AI assumptions by letting you review and add context before generating notes. Multiple quotes detection automatically generates separate quote variants when you discuss options like "Option 1" or "Quote A/B".
      </p>
    </section>

    <!-- Colour Theme Preferences -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Colour theme</h2>
        <span>Pick an accent colour for the app</span>
      </div>

      <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
        <label for="colorThemeSelect" style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">Accent colour</label>
        <select id="colorThemeSelect" style="padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border); background: var(--card); color: #e2e8f0; box-shadow: var(--button-inset);">
          <option value="blue">Blue (default)</option>
          <option value="green">Green</option>
        </select>
      </div>

      <p class="hint">Changing the accent colour updates buttons, highlights, and other green elements throughout the app.</p>
    </section>

    <!-- AI Instructions Configuration -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>AI Instructions</h2>
        <span>Customize system prompts for AI agents</span>
      </div>

      <div class="toolbar">
        <button id="ai-save-btn" class="secondary">Save AI Instructions</button>
        <button id="ai-reset-btn" class="secondary">Reset to Defaults</button>
      </div>

      <p class="hint">
        These instructions control how the AI behaves in different contexts. Edit them to customize the AI's behavior for your specific needs.
      </p>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <label style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">Agent Chat Instructions</label>
          <textarea
            id="ai-agent-chat-instructions"
            style="font-family: monospace; font-size: 0.7rem; padding: 8px; border: 1px solid var(--border); border-radius: 8px; min-height: 300px; resize: vertical;"
            placeholder="Agent chat system prompt..."
          ></textarea>
          <p class="hint" style="margin: 0;">Used when the AI assistant chats with you about survey details.</p>
        </div>

        <div style="display: flex; flex-direction: column; gap: 8px;">
          <label style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">Section Tweak Instructions</label>
          <textarea
            id="ai-tweak-section-instructions"
            style="font-family: monospace; font-size: 0.7rem; padding: 8px; border: 1px solid var(--border); border-radius: 8px; min-height: 300px; resize: vertical;"
            placeholder="Section tweak system prompt..."
          ></textarea>
          <p class="hint" style="margin: 0;">Used when the AI improves survey section notes based on your instructions.</p>
        </div>
      </div>

      <p class="status" id="ai-status"></p>
    </section>

    <!-- LEFT: section schema editor -->
    <section class="card">
      <div class="card-header">
        <h2>Notes sections</h2>
        <span>Edit the section list & order</span>
        <span class="pill small" id="sections-count-pill">0 sections</span>
      </div>

      <div class="toolbar">
        <button id="sections-add-btn">+ Add section</button>
        <button id="sections-save-btn" class="secondary">Save to your profile</button>
        <button id="sections-export-btn" class="secondary">Export JSON</button>
        <button id="sections-import-btn" class="secondary">Import JSON</button>
      </div>
      <p class="hint">
        These control the section headings in the main app. The worker fills them with text, but the
        <strong>names & order are defined here</strong>. ‚ÄúFuture plans‚Äù will always be kept last by the app.
      </p>

      <div class="rows" id="sections-rows"></div>

      <p class="status" id="sections-status">Loading sections‚Ä¶</p>
      <input type="file" id="sections-import-input" accept="application/json" style="display:none;">
    </section>

    <!-- Section rules guidance -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Notes section rules</h2>
        <span>What content belongs in each section</span>
      </div>

      <div class="toolbar">
        <button id="section-rules-save-btn" class="secondary">Save rules to your profile</button>
        <button id="section-rules-reset-btn" class="secondary">Reset rules to defaults</button>
      </div>

        <p class="hint">
          Use these rules to spell out what should go into each notes section. The text is shown as editable AI instructions for
          every section, so you can keep guidance in sync with how your team captures information. Keep the "New boiler and controls" rules short and focused: what is coming out,
          what is being installed, which controls stay or change, where everything sits, and details of any cylinders, tanks,
          sealed system kits, and radiators.
        </p>

      <div class="rule-rows" id="section-rules-rows"></div>
      <p class="status" id="section-rules-status">Loading section rules‚Ä¶</p>

      <!-- AI Instructions for Notes Generation -->
      <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
        <h3 style="margin: 0; font-size: 0.9rem; letter-spacing: .02em;">AI Instructions for Notes Generation</h3>
        <div style="display: flex; flex-direction: column; gap: 6px; margin-top: 8px;">
          <label for="notes-instructions" style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">
            AI instructions for notes
          </label>
          <textarea
            id="notes-instructions"
            style="font-family: monospace; font-size: 0.7rem; padding: 8px; border: 1px solid var(--border); border-radius: 8px; min-height: 280px; resize: vertical;"
            placeholder="Notes system prompt..."
            spellcheck="false"
          ></textarea>
        </div>

        <button id="notes-reset-btn" type="button" class="secondary">Reset to recommended notes rules</button>
      </div>
    </section>

    <!-- RIGHT: checklist editor -->
    <section class="card">
      <div class="card-header">
        <h2>Survey checklist</h2>
        <span>Groups, IDs & hints</span>
        <span class="pill small" id="checklist-count-pill">0 items</span>
      </div>

      <div class="toolbar">
        <button id="checklist-add-btn">+ Add item</button>
        <button id="checklist-save-btn" class="secondary">Save to your profile</button>
        <button id="checklist-export-btn" class="secondary">Export JSON</button>
        <button id="checklist-import-btn" class="secondary">Import JSON</button>
      </div>
        <p class="hint">
          Click <strong>+ Add item</strong>, set a stable <strong>ID</strong>, then choose a <strong>section</strong> from the dropdown to
          avoid typos. Add a <strong>group</strong>, <strong>label</strong>, and optional <strong>hint</strong>. Click <strong>‚ãØ</strong> to expand and edit
          <strong>AI templates</strong> (plainText &amp; naturalLanguage). The worker uses these templates to generate section content.
        </p>

      <div class="checklist-rows" id="checklist-rows"></div>

      <p class="status" id="checklist-status">Loading checklist‚Ä¶</p>
      <input type="file" id="checklist-import-input" accept="application/json" style="display:none;">
    </section>
  </main>

  <script>
    // Storage keys (match index.html)
    const SECTION_STORAGE_KEY = "depot.sectionSchema";
    const LEGACY_SECTION_STORAGE_KEY = "surveybrain-schema";
    const CHECKLIST_STORAGE_KEY = "depot.checklistConfig";
    const SECTION_RULES_STORAGE_KEY = "depot.sectionRules";
    const AI_INSTRUCTIONS_STORAGE_KEY = "depot.aiInstructions";
    const DEFAULT_NOTES_INSTRUCTIONS = `
You are generating engineer-friendly "job notes" from a voice transcript for a domestic heating job.

General rules:
- Prefer clear, non-duplicated bullets.
- Avoid contradictions in the same section.
- When there is a conflict between earlier speculative text and later, typed "summary" lines from the adviser, ALWAYS prefer the later summary lines.
- Preserve the adviser's intent, not the raw transcription glitches.

High-priority source of truth:
- If the transcript contains a clearly typed list or short summary entered by the adviser (for example in a "Customer summary", "Engineer notes", or "typed notes" section), treat these as the final instructions.
- When such a summary contradicts earlier spoken content, follow the summary and drop the conflicting spoken content.

---

### Gas supply rules (Pipe work section)

When generating Pipe work bullets about the gas supply:

1. If the transcript contains phrases like:
   - "increase gas supply" OR "upgrade gas supply"
   AND
   - a route phrase such as "from meter", "via cupboards", "through cupboards", "along the same route", "to the boiler position"
   then:
   - Treat that as the authoritative gas instruction.
   - Generate ONE clear bullet describing the upgrade and route, for example:

     - "‚Ä¢ Upgrade gas supply from meter via cupboards to new boiler position (size to suit 24kW boiler output plus diversity);"

   - Do NOT also generate a bullet stating that the "existing 15mm gas supply is adequate". Avoid any wording that contradicts the upgrade.

2. If the transcript only says the gas is adequate, with no "increase"/"upgrade" wording or route:
   - Generate a simple confirmation bullet, for example:

     - "‚Ä¢ Existing gas supply confirmed adequate for new boiler;"

3. Never output both "existing 15mm gas supply confirmed adequate" AND "increase gas supply" in the same job. If upgrade wording is present, the upgrade wins and the "adequate" line should not appear.

---

### Primary pipework (primaries) rules (Pipe work section)

When generating Pipe work bullets about primaries (primary flow and return):

1. Look for phrases in the transcript such as:
   - "primaries", "primary pipework", "flow and return"
   AND
   - power or sizing context such as "set up for up to 18 kW", "you've got 24", "change them to 28mm", "24Ri", etc.

2. When these are present, generate two distinct bullets instead of a single vague one:

   - A route / location bullet tying the change to the physical path, for example:
     - "‚Ä¢ Replace primary flow and return between loft hatches and airing cupboard;"

   - A sizing / justification bullet, for example:
     - "‚Ä¢ Upgrade primary pipework to 28mm to allow full 24kW boiler output without overheating;"

3. Avoid vague or duplicate wording when the above bullets are used. For example, drop weaker lines like:
   - "Pipework between loft hatches and in airing cupboard to be replaced;"
   if they would duplicate a clearer, more explicit primaries bullet.

4. If the transcript clearly states that existing primaries are undersized (e.g. "current pipework is set up for up to 18kW and you‚Äôve got 24"), ensure the notes include the reason:
   - Mention that the upgrade to 28mm is to match boiler output and reduce overheating / cycling.

---

### S-plan, pump, and open vent / cold feed assembly

When the transcript mentions replacing the pump, mid-position valve, or open vent / cold feed:

- Use clear, standard wording such as:
  - "‚Ä¢ Replace primary pump and motorised valve assembly;"
  - "‚Ä¢ Replace open vent and cold feed arrangement as part of system upgrade;"
  - "‚Ä¢ Install new S-plan with two motorised valves (one heating, one hot water) and automatic bypass;"

- Normalise common mis-heard phrases:
  - "open venting code fade" ‚Üí "open vent / cold feed arrangement".

---

### Brand and component clean-ups

Correct obvious transcription errors for well-known components:

- "Ferox TF1" ‚Üí "Fernox TF1"
- Similar mis-spellings of common filters, inhibitors, and boiler models should be corrected to the standard brand spelling where unambiguous.

---

### General clean-up and de-duplication

- Remove "noise" bullets that do not contain a clear instruction or could cause confusion.
  - Example to drop: "possible issues with pipework in screening area;" if it has no route, size, or action.
- Favour fewer, clearer bullets over many vague ones.
- Where possible, make each bullet:
  - Specific to a location or route (e.g. "between loft hatches and airing cupboard").
  - Explicit about size or rating when changing pipework (e.g. "upgrade to 28mm").
  - Consistent with any final typed summary from the adviser.

Output concise, engineer-ready bullets in each section: no waffle, no contradictions, just what needs doing and why.
`;
    const LS_AUTOSAVE_KEY = "surveyBrainAutosave";
    const WORKER_URL_STORAGE_KEYS = ["depot.workerUrl", "depot-worker-url"];
    const ADDITIONAL_STORAGE_KEYS = [
      "depot-output-schema",
      "depot.notesSchema.v1",
      "depot-checklist-state"
    ];
    const FUTURE_PLANS_NAME = "Future plans";

    // --- Helpers ---
    function getActiveUserId() {
      try {
        const raw = localStorage.getItem('depot.userInfo');
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        return parsed?.id || parsed?._id || parsed?.userId || parsed?.email || parsed?.username || null;
      } catch (_) {
        return null;
      }
    }

    function getUserScopedKey(baseKey) {
      const userId = getActiveUserId();
      return userId ? `${baseKey}::user:${userId}` : null;
    }

    function readJSONSafe(key) {
      const scopedKey = getUserScopedKey(key);
      const keysToTry = scopedKey ? [scopedKey, key] : [key];
      for (const candidate of keysToTry) {
        try {
          const raw = localStorage.getItem(candidate);
          if (!raw) continue;
          return JSON.parse(raw);
        } catch (_) {
          // ignore and try fallback
        }
      }
      return null;
    }

    function writeJSONSafe(key, value) {
      const payload = JSON.stringify(value);
      const scopedKey = getUserScopedKey(key);
      try { localStorage.setItem(key, payload); } catch (_) { /* ignore */ }
      if (scopedKey) {
        try { localStorage.setItem(scopedKey, payload); } catch (_) { /* ignore */ }
      }
    }

    function readStringSafe(key) {
      const scopedKey = getUserScopedKey(key);
      const keysToTry = scopedKey ? [scopedKey, key] : [key];
      for (const candidate of keysToTry) {
        try {
          const raw = localStorage.getItem(candidate);
          if (raw != null) return raw;
        } catch (_) {
          // ignore and try fallback
        }
      }
      return null;
    }

    function writeStringSafe(key, value) {
      const scopedKey = getUserScopedKey(key);
      try { localStorage.setItem(key, value); } catch (_) { /* ignore */ }
      if (scopedKey) {
        try { localStorage.setItem(scopedKey, value); } catch (_) { /* ignore */ }
      }
    }

    function clearStoredAppData() {
      const keys = new Set([
        SECTION_STORAGE_KEY,
        LEGACY_SECTION_STORAGE_KEY,
        CHECKLIST_STORAGE_KEY,
        SECTION_RULES_STORAGE_KEY,
        LS_AUTOSAVE_KEY,
        ...WORKER_URL_STORAGE_KEYS,
        ...ADDITIONAL_STORAGE_KEYS
      ]);

      const userScopedKeys = [
        SECTION_STORAGE_KEY,
        LEGACY_SECTION_STORAGE_KEY,
        CHECKLIST_STORAGE_KEY,
        SECTION_RULES_STORAGE_KEY,
        AI_INSTRUCTIONS_STORAGE_KEY,
        LS_AUTOSAVE_KEY,
        ...WORKER_URL_STORAGE_KEYS
      ].map(getUserScopedKey).filter(Boolean);
      userScopedKeys.forEach((key) => keys.add(key));

      try {
        for (let i = 0; i < localStorage.length; i += 1) {
          const key = localStorage.key(i);
          if (!key) continue;
          const lower = key.toLowerCase();
          if (lower.includes("depot") || lower.includes("surveybrain")) {
            keys.add(key);
          }
        }
      } catch (err) {
        console.warn("Could not enumerate localStorage keys during reset", err);
      }

      keys.forEach((key) => {
        try {
          localStorage.removeItem(key);
        } catch (err) {
          console.warn("Failed to remove localStorage key", key, err);
        }
      });

      try {
        sessionStorage.clear();
      } catch (err) {
        console.warn("Session storage could not be cleared", err);
      }
    }

    function sanitiseSectionSchema(input) {
      const asArray = (value) => {
        if (!value) return [];
        if (Array.isArray(value)) return value;
        if (value && typeof value === "object" && Array.isArray(value.sections)) {
          return value.sections;
        }
        return [];
      };

      const rawEntries = asArray(input);
      const prepared = [];
      rawEntries.forEach((entry, idx) => {
        if (!entry) return;
        const rawName = entry.name ?? entry.section ?? entry.title ?? entry.heading;
        const name = typeof rawName === "string" ? rawName.trim() : "";
        if (!name || name === "Arse_cover_notes") return;
        const rawDescription = entry.description ?? entry.hint ?? "";
        const description = typeof rawDescription === "string"
          ? rawDescription.trim()
          : String(rawDescription || "").trim();
        const order = typeof entry.order === "number" ? entry.order : idx + 1;
        prepared.push({ name, description, order, idx });
      });

      prepared.sort((a, b) => {
        const aHasOrder = typeof a.order === "number";
        const bHasOrder = typeof b.order === "number";
        if (aHasOrder && bHasOrder && a.order !== b.order) {
          return a.order - b.order;
        }
        if (aHasOrder && !bHasOrder) return -1;
        if (!aHasOrder && bHasOrder) return 1;
        return a.idx - b.idx;
      });

      const unique = [];
      const seen = new Set();
      prepared.forEach((entry) => {
        if (seen.has(entry.name)) return;
        seen.add(entry.name);
        unique.push({
          name: entry.name,
          description: entry.description || "",
          order: entry.order
        });
      });

      // Keep Future plans last, ensure it exists
      let withoutFuture = unique.filter((entry) => entry.name !== FUTURE_PLANS_NAME);
      let future = unique.find((entry) => entry.name === FUTURE_PLANS_NAME);
      if (!future) {
        future = {
          name: FUTURE_PLANS_NAME,
          description: "Notes about any future work or follow-on visits.",
          order: withoutFuture.length + 1
        };
      } else if (!future.description) {
        future = {
          ...future,
          description: "Notes about any future work or follow-on visits."
        };
      }

      const final = [...withoutFuture, future].map((entry, idx) => ({
        name: entry.name,
        description: entry.description || "",
        order: idx + 1
      }));

      return final;
    }

    function sanitiseChecklistConfig(value) {
      const asArray = (input) => {
        if (!input) return [];
        if (Array.isArray(input)) return input;
        if (input && typeof input === "object" && Array.isArray(input.items)) {
          return input.items;
        }
        return [];
      };

      const entries = asArray(value);
      const seen = new Set();
      const cleaned = [];

      entries.forEach((item) => {
        if (!item) return;
        const id = item.id != null ? String(item.id).trim() : "";
        const label = item.label != null ? String(item.label).trim() : "";
        if (!id || !label || seen.has(id)) return;
        seen.add(id);
        cleaned.push({
          id,
          group: (item.group || item.category || "Checklist").trim(),
          section: (item.section || item.sectionName || item.depotSection || "").trim(),
          label,
          hint: (item.hint || item.description || "").trim()
        });
      });

      return cleaned;
    }

    async function fetchJSON(path) {
      try {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) return null;
        return await res.json();
      } catch (_) {
        return null;
      }
    }

    // --- Section editor state / rendering ---
    const sectionsRowsEl = document.getElementById("sections-rows");
    const sectionsStatusEl = document.getElementById("sections-status");
    const sectionsCountPill = document.getElementById("sections-count-pill");
    const sectionRulesRowsEl = document.getElementById("section-rules-rows");
    const sectionRulesStatusEl = document.getElementById("section-rules-status");

    let sections = [];
    let sectionRules = {};

    function getDefaultSectionRules() {
      return {
        "Needs": "What the customer is asking for, priorities, budget, pain points, must-haves, and any red lines.",
        "Working at heights": "Safe access requirements for roofs, lofts, scaffolding, and working platforms.",
        "System characteristics": "Current heat source, system type, fuel, pipe sizes, hot water arrangement, and key locations.",
        "Components that require assistance": "Anything heavy or awkward that needs an extra person or special handling.",
        "Restrictions to work": "Timing, access windows, parking, permits, noisy hours, or rooms that are off limits.",
        "External hazards": "Asbestos, fragile roofs, pets, alarms, electrics, or other site-specific risks to flag early.",
        "Delivery notes": "Best drop-off point, contact name/number, site access codes, or parking instructions for deliveries.",
        "Office notes": "Administrative or pricing notes that planners need but do not belong in customer-facing sections.",
        "New boiler and controls": "Keep it simple: what appliance/controls are coming out, what is going in, which controls stay the same, which change, and where everything is being installed. Include cylinders, tanks, sealed system kits, and radiators if they are part of the job.",
        "Flue": "Route, termination type/position, lengths, terminals, clearances, plume kits, and any making good.",
        "Pipe work": "Upgrades, reroutes, sizes, isolation points, gas run details, and any dead legs being removed.",
        "Disruption": "Lifting floors, making good, decoration, access panels, and anything that will disturb finishes.",
        "Customer actions": "Tasks the customer must do before/after install: clearances, power, access, permissions, or paperwork.",
        "Future plans": "Follow-on work, phased upgrades, or extra visits to complete outstanding items."
      };
    }

    function renderSections() {
      sectionsRowsEl.innerHTML = "";
      if (!sections.length) {
        sectionsRowsEl.innerHTML = '<div class="row"><span class="order">‚Äì</span><div class="hint" style="grid-column: span 3;">No sections defined yet. Add your first section above.</div></div>';
        sectionsCountPill.textContent = "0 sections";
        return;
      }
      sectionsCountPill.textContent = sections.length + (sections.length === 1 ? " section" : " sections");

      sections.forEach((sec, idx) => {
        const row = document.createElement("div");
        row.className = "row";

        const orderSpan = document.createElement("span");
        orderSpan.className = "order";
        orderSpan.textContent = idx + 1;

        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = sec.name || "";
        nameInput.placeholder = "Section name";
        nameInput.oninput = () => {
          sections[idx].name = nameInput.value.trim();
        };

        const descInput = document.createElement("textarea");
        descInput.value = sec.description || "";
        descInput.placeholder = "Installer hint / description (optional)";
        descInput.oninput = () => {
          sections[idx].description = descInput.value.trim();
        };

        const controls = document.createElement("div");
        controls.className = "row-controls";

        const upBtn = document.createElement("button");
        upBtn.className = "small secondary";
        upBtn.textContent = "‚ñ≤";
        upBtn.disabled = idx === 0;
        upBtn.onclick = () => {
          if (idx === 0) return;
          const tmp = sections[idx - 1];
          sections[idx - 1] = sections[idx];
          sections[idx] = tmp;
          renderSections();
        };

        const downBtn = document.createElement("button");
        downBtn.className = "small secondary";
        downBtn.textContent = "‚ñº";
        downBtn.disabled = idx === sections.length - 1;
        downBtn.onclick = () => {
          if (idx === sections.length - 1) return;
          const tmp = sections[idx + 1];
          sections[idx + 1] = sections[idx];
          sections[idx] = tmp;
          renderSections();
        };

        const delBtn = document.createElement("button");
        delBtn.className = "small danger";
        delBtn.textContent = "‚úï";
        delBtn.onclick = () => {
          if (!confirm(`Remove section "${sec.name || "Untitled"}"?`)) return;
          sections.splice(idx, 1);
          renderSections();
        };

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(delBtn);

        row.appendChild(orderSpan);
        row.appendChild(nameInput);
        row.appendChild(descInput);
        row.appendChild(controls);
        sectionsRowsEl.appendChild(row);
      });

      renderSectionRules();
      renderChecklistEditor();
    }

    function renderSectionRules() {
      if (!sectionRulesRowsEl) return;

      sectionRulesRowsEl.innerHTML = "";
      const names = sections.length ? sections.map((sec) => sec.name) : Object.keys(sectionRules);

      if (!names.length) {
        sectionRulesRowsEl.innerHTML = '<div class="rule-row"><span class="hint">No sections available yet.</span></div>';
        sectionRulesStatusEl.textContent = "No section rules to show";
        return;
      }

        names.forEach((name) => {
          const row = document.createElement("div");
          row.className = "rule-row";

          const title = document.createElement("strong");
          title.textContent = name || "Untitled";

          const instructionsWrapper = document.createElement("div");
          instructionsWrapper.className = "rule-instructions";

          const instructionsLabel = document.createElement("span");
          instructionsLabel.className = "hint";
          instructionsLabel.textContent = "AI instructions for this section";

          const textarea = document.createElement("textarea");
          textarea.value = sectionRules[name] || "";
          textarea.placeholder = "Add guidance for what belongs in this section";
          textarea.oninput = () => {
            sectionRules[name] = textarea.value.trim();
          };

          instructionsWrapper.appendChild(instructionsLabel);
          instructionsWrapper.appendChild(textarea);

          row.appendChild(title);
          row.appendChild(instructionsWrapper);
          sectionRulesRowsEl.appendChild(row);
        });

      sectionRulesStatusEl.textContent = `Showing rules for ${names.length} section${names.length === 1 ? "" : "s"}.`;
    }

    async function loadSections() {
      sectionsStatusEl.textContent = "Loading sections‚Ä¶";
      let used = "defaults";

      // 1) Read overrides from localStorage (new key then legacy)
      const overrideNew = readJSONSafe(SECTION_STORAGE_KEY);
      const overrideLegacy = !overrideNew ? readJSONSafe(LEGACY_SECTION_STORAGE_KEY) : null;

      let local = overrideNew || overrideLegacy;
      let defaults = null;

      // 2) Fetch defaults from the bundled output schema
      defaults = await fetchJSON("depot.output.schema.json");

      const candidate = sanitiseSectionSchema(
        Array.isArray(local) && local.length ? local : defaults
      );

      sections = candidate;
      sectionsStatusEl.innerHTML = `Loaded <strong>${sections.length}</strong> sections (${overrideNew || overrideLegacy ? "from your profile" : "from bundled schema file"}).`;
      renderSections();
    }

    function saveSectionsToLocal() {
      const cleaned = sanitiseSectionSchema(sections);
      // Store as { sections: [...] } for clarity
      const payload = { sections: cleaned };
      writeJSONSafe(SECTION_STORAGE_KEY, payload);
      sectionsStatusEl.innerHTML = `Saved <strong>${cleaned.length}</strong> sections to your profile. Main app will pick these up on next load.`;
      renderChecklistEditor();
    }

    function exportSectionsJSON() {
      const cleaned = sanitiseSectionSchema(sections);
      const payload = { sections: cleaned };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `notes.sections.schema-${ts}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      sectionsStatusEl.innerHTML = `Exported <strong>${cleaned.length}</strong> sections as JSON file.`;
    }

    function importSectionsJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          const cleaned = sanitiseSectionSchema(data);
          sections = cleaned;
          writeJSONSafe(SECTION_STORAGE_KEY, { sections: cleaned });
          renderSections();
          sectionsStatusEl.innerHTML = `Imported <strong>${cleaned.length}</strong> sections and saved to your profile.`;
        } catch (err) {
          console.error(err);
          sectionsStatusEl.classList.add("error");
          sectionsStatusEl.innerHTML = `<strong>Error:</strong> Could not parse JSON file.`;
        }
      };
      reader.readAsText(file);
    }

    // --- Section rules state / rendering ---
    function loadSectionRules() {
      const defaults = getDefaultSectionRules();
      sectionRules = { ...defaults };

      const stored = readJSONSafe(SECTION_RULES_STORAGE_KEY);
      if (stored && typeof stored === "object" && !Array.isArray(stored)) {
        sectionRules = { ...defaults, ...stored };
      }

      renderSectionRules();
      sectionRulesStatusEl.textContent = `Loaded rules for ${Object.keys(sectionRules).length} sections.`;
    }

    function saveSectionRules() {
      try {
        writeJSONSafe(SECTION_RULES_STORAGE_KEY, sectionRules);
        sectionRulesStatusEl.textContent = "Section rules saved to your profile.";
      } catch (err) {
        alert("Unable to save section rules: " + (err?.message || err));
      }
    }

    function resetSectionRules() {
      sectionRules = getDefaultSectionRules();
      renderSectionRules();
      sectionRulesStatusEl.textContent = "Section rules reset to defaults.";
    }

    // --- Checklist editor state / rendering ---
    const checklistRowsEl = document.getElementById("checklist-rows");
    const checklistStatusEl = document.getElementById("checklist-status");
    const checklistCountPill = document.getElementById("checklist-count-pill");

    let checklist = [];

    function renderChecklistEditor() {
      checklistRowsEl.innerHTML = "";
      if (!checklist.length) {
        checklistRowsEl.innerHTML = '<div class="checklist-row"><span class="order">‚Äì</span><div class="hint" style="grid-column: span 5;">No checklist items yet. Add your first item above.</div></div>';
        checklistCountPill.textContent = "0 items";
        return;
      }
      checklistCountPill.textContent = checklist.length + (checklist.length === 1 ? " item" : " items");

      checklist.forEach((item, idx) => {
        const row = document.createElement("div");
        row.className = "checklist-row";

        const orderSpan = document.createElement("span");
        orderSpan.className = "order";
        orderSpan.textContent = idx + 1;

        const idInput = document.createElement("input");
        idInput.type = "text";
        idInput.value = item.id || "";
        idInput.placeholder = "ID (stable)";
        idInput.oninput = () => {
          checklist[idx].id = idInput.value.trim();
        };

        const groupInput = document.createElement("input");
        groupInput.type = "text";
        groupInput.value = item.group || "";
        groupInput.placeholder = "Group (e.g. Boiler & controls)";
        groupInput.oninput = () => {
          checklist[idx].group = groupInput.value.trim();
        };

        const sectionInput = document.createElement("select");
        const placeholderOption = document.createElement("option");
        placeholderOption.value = "";
        placeholderOption.textContent = "Choose section (optional)";
        sectionInput.appendChild(placeholderOption);

        const availableSections = (sections || []).map((sec) => sec.name).filter(Boolean);
        availableSections.forEach((name) => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          sectionInput.appendChild(opt);
        });

        if (item.section && !availableSections.includes(item.section)) {
          const customOpt = document.createElement("option");
          customOpt.value = item.section;
          customOpt.textContent = `${item.section} (custom)`;
          sectionInput.appendChild(customOpt);
        }

        sectionInput.value = item.section || "";
        sectionInput.onchange = () => {
          checklist[idx].section = sectionInput.value.trim();
        };

        const labelInput = document.createElement("input");
        labelInput.type = "text";
        labelInput.value = item.label || "";
        labelInput.placeholder = "Question / label";
        labelInput.oninput = () => {
          checklist[idx].label = labelInput.value.trim();
        };

        const hintInput = document.createElement("input");
        hintInput.type = "text";
        hintInput.value = item.hint || "";
        hintInput.placeholder = "Hint (optional)";
        hintInput.oninput = () => {
          checklist[idx].hint = hintInput.value.trim();
        };

        // Expand button to show plainText and naturalLanguage
        const expandBtn = document.createElement("button");
        expandBtn.className = "small secondary";
        expandBtn.textContent = "‚ãØ";
        expandBtn.title = "Show/hide AI templates";
        expandBtn.style.fontSize = "1.2rem";
        expandBtn.style.padding = "2px 8px";

        const controls = document.createElement("div");
        controls.className = "row-controls";

        const upBtn = document.createElement("button");
        upBtn.className = "small secondary";
        upBtn.textContent = "‚ñ≤";
        upBtn.disabled = idx === 0;
        upBtn.onclick = () => {
          if (idx === 0) return;
          const tmp = checklist[idx - 1];
          checklist[idx - 1] = checklist[idx];
          checklist[idx] = tmp;
          renderChecklistEditor();
        };

        const downBtn = document.createElement("button");
        downBtn.className = "small secondary";
        downBtn.textContent = "‚ñº";
        downBtn.disabled = idx === checklist.length - 1;
        downBtn.onclick = () => {
          if (idx === checklist.length - 1) return;
          const tmp = checklist[idx + 1];
          checklist[idx + 1] = checklist[idx];
          checklist[idx] = tmp;
          renderChecklistEditor();
        };

        const delBtn = document.createElement("button");
        delBtn.className = "small danger";
        delBtn.textContent = "‚úï";
        delBtn.onclick = () => {
          if (!confirm(`Remove checklist item "${item.label || item.id || "Untitled"}"?`)) return;
          checklist.splice(idx, 1);
          renderChecklistEditor();
        };

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(delBtn);

        // Expandable section for AI templates
        const expandableSection = document.createElement("div");
        expandableSection.style.gridColumn = "1 / -1";
        expandableSection.style.display = "none";
        expandableSection.style.padding = "12px";
        expandableSection.style.background = "#f8fafc";
        expandableSection.style.borderRadius = "8px";
        expandableSection.style.marginTop = "8px";

        const templatesLabel = document.createElement("div");
        templatesLabel.style.fontSize = "0.75rem";
        templatesLabel.style.fontWeight = "600";
        templatesLabel.style.marginBottom = "8px";
        templatesLabel.textContent = "AI Templates (used by worker to generate section content)";

        const plainTextLabel = document.createElement("label");
        plainTextLabel.style.display = "block";
        plainTextLabel.style.fontSize = "0.7rem";
        plainTextLabel.style.marginTop = "8px";
        plainTextLabel.style.marginBottom = "4px";
        plainTextLabel.textContent = "Plain Text Template (bullet points):";

        const plainTextArea = document.createElement("textarea");
        plainTextArea.value = item.plainText || "";
        plainTextArea.placeholder = "Bullet-point style template for plainText...";
        plainTextArea.rows = 3;
        plainTextArea.style.width = "100%";
        plainTextArea.style.fontFamily = "monospace";
        plainTextArea.style.fontSize = "0.7rem";
        plainTextArea.style.padding = "8px";
        plainTextArea.style.border = "1px solid #d4dbe5";
        plainTextArea.style.borderRadius = "6px";
        plainTextArea.oninput = () => {
          checklist[idx].plainText = plainTextArea.value;
        };

        const naturalLanguageLabel = document.createElement("label");
        naturalLanguageLabel.style.display = "block";
        naturalLanguageLabel.style.fontSize = "0.7rem";
        naturalLanguageLabel.style.marginTop = "8px";
        naturalLanguageLabel.style.marginBottom = "4px";
        naturalLanguageLabel.textContent = "Natural Language Template (prose):";

        const naturalLanguageArea = document.createElement("textarea");
        naturalLanguageArea.value = item.naturalLanguage || "";
        naturalLanguageArea.placeholder = "Prose description template for naturalLanguage...";
        naturalLanguageArea.rows = 3;
        naturalLanguageArea.style.width = "100%";
        naturalLanguageArea.style.fontFamily = "monospace";
        naturalLanguageArea.style.fontSize = "0.7rem";
        naturalLanguageArea.style.padding = "8px";
        naturalLanguageArea.style.border = "1px solid #d4dbe5";
        naturalLanguageArea.style.borderRadius = "6px";
        naturalLanguageArea.oninput = () => {
          checklist[idx].naturalLanguage = naturalLanguageArea.value;
        };

        expandableSection.appendChild(templatesLabel);
        expandableSection.appendChild(plainTextLabel);
        expandableSection.appendChild(plainTextArea);
        expandableSection.appendChild(naturalLanguageLabel);
        expandableSection.appendChild(naturalLanguageArea);

        // Toggle expand button
        expandBtn.onclick = () => {
          const isHidden = expandableSection.style.display === "none";
          expandableSection.style.display = isHidden ? "block" : "none";
          expandBtn.textContent = isHidden ? "‚àí" : "‚ãØ";
        };

        row.appendChild(orderSpan);
        row.appendChild(idInput);
        row.appendChild(groupInput);
        row.appendChild(sectionInput);
        row.appendChild(labelInput);
        row.appendChild(hintInput);
        row.appendChild(expandBtn);
        row.appendChild(controls);
        row.appendChild(expandableSection);

        checklistRowsEl.appendChild(row);
      });
    }

    async function loadChecklist() {
      checklistStatusEl.textContent = "Loading checklist‚Ä¶";

      const override = sanitiseChecklistConfig(readJSONSafe(CHECKLIST_STORAGE_KEY));
      const defaultsRaw = await fetchJSON("checklist.config.json");
      const defaults = sanitiseChecklistConfig(defaultsRaw);

      const candidate = override.length ? override : defaults;
      checklist = candidate;

      const source = override.length ? "your profile" : "checklist.config.json";
      checklistStatusEl.innerHTML = `Loaded <strong>${checklist.length}</strong> items (${source}).`;
      renderChecklistEditor();
    }

    function saveChecklistToLocal() {
      const cleaned = sanitiseChecklistConfig(checklist);
      const payload = { items: cleaned };
      writeJSONSafe(CHECKLIST_STORAGE_KEY, payload);
      checklistStatusEl.innerHTML = `Saved <strong>${cleaned.length}</strong> checklist items to your profile.`;
    }

    function exportChecklistJSON() {
      const cleaned = sanitiseChecklistConfig(checklist);
      const payload = { items: cleaned };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `notes.checklist-${ts}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      checklistStatusEl.innerHTML = `Exported <strong>${cleaned.length}</strong> checklist items as JSON file.`;
    }

    function importChecklistJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          const cleaned = sanitiseChecklistConfig(data);
          checklist = cleaned;
          writeJSONSafe(CHECKLIST_STORAGE_KEY, { items: cleaned });
          renderChecklistEditor();
          checklistStatusEl.innerHTML = `Imported <strong>${cleaned.length}</strong> checklist items and saved to your profile.`;
        } catch (err) {
          console.error(err);
          checklistStatusEl.classList.add("error");
          checklistStatusEl.innerHTML = `<strong>Error:</strong> Could not parse JSON file.`;
        }
      };
      reader.readAsText(file);
    }

    // --- Wire up buttons ---
    const forceReloadBtn = document.getElementById("forceReloadBtn");
    if (forceReloadBtn) {
      forceReloadBtn.addEventListener("click", () => {
        const confirmReset = confirm("This will clear all stored Survey Brain data on this device. Continue?");
        if (!confirmReset) return;
        const originalLabel = forceReloadBtn.textContent;
        forceReloadBtn.disabled = true;
        forceReloadBtn.textContent = "Resetting‚Ä¶";
        try {
          clearStoredAppData();
          window.location.replace("index.html");
        } catch (err) {
          console.error("Force reload/reset failed", err);
          alert("Failed to reset stored data. Please hard refresh the page.");
          forceReloadBtn.disabled = false;
          forceReloadBtn.textContent = originalLabel;
        }
      });
    }

    document.getElementById("sections-add-btn").onclick = () => {
      sections.push({
        name: "",
        description: "",
        order: sections.length + 1
      });
      renderSections();
    };
    document.getElementById("sections-save-btn").onclick = saveSectionsToLocal;
    document.getElementById("sections-export-btn").onclick = exportSectionsJSON;
    document.getElementById("sections-import-btn").onclick = () => {
      document.getElementById("sections-import-input").click();
    };
    document.getElementById("sections-import-input").onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      importSectionsJSON(file);
      e.target.value = "";
    };

    document.getElementById("section-rules-save-btn")?.addEventListener("click", saveSectionRules);
    document.getElementById("section-rules-reset-btn")?.addEventListener("click", resetSectionRules);

    document.getElementById("checklist-add-btn").onclick = () => {
      checklist.push({
        id: "",
        group: "Checklist",
        section: "",
        label: "",
        hint: ""
      });
      renderChecklistEditor();
    };
    document.getElementById("checklist-save-btn").onclick = saveChecklistToLocal;
    document.getElementById("checklist-export-btn").onclick = exportChecklistJSON;
    document.getElementById("checklist-import-btn").onclick = () => {
      document.getElementById("checklist-import-input").click();
    };
    document.getElementById("checklist-import-input").onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      importChecklistJSON(file);
      e.target.value = "";
    };

    // --- Export Format Preferences ---
    function loadExportFormat() {
      const stored = readStringSafe('exportFormat');
      const format = stored || 'json';
      const radioBtn = document.getElementById(format === 'csv' ? 'formatCSV' : 'formatJSON');
      if (radioBtn) radioBtn.checked = true;
    }

    function saveExportFormat(format) {
      writeStringSafe('exportFormat', format);
    }

    document.querySelectorAll('input[name="exportFormat"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        saveExportFormat(e.target.value);
      });
    });

    // --- AI Instructions ---
    function getDefaultAIInstructions() {
      return {
        agentChat: `You are an AI assistant helping with heating survey work for a British Gas style boiler installation surveyor.

You have access to:
- The current survey sections and notes
- The transcript of conversations
- Reference materials from the knowledge database

Your job is to:
1. Answer questions about the survey, products, pricing, or technical details
2. Provide helpful suggestions based on the context
3. Help fill in missing information
4. Be concise but accurate

SANITY CHECKING:
- Actively correct obvious transcription mistakes using the context provided (e.g., if a pipe size looks wrong, normalise it to the nearest standard size).
- Standard pipework sizes are 8/10mm (microbore), 15mm, 22mm, 28mm, and 35mm‚Äîprefer these when resolving ambiguities.
- Prefer the most recent reference material versions (e.g., the latest pricebook such as November 2025) when multiple versions exist.

IMPORTANT:
- Use the reference materials to provide accurate product specifications and pricing
- If you don't know something, say so
- Keep responses brief and actionable
- Focus on helping complete the survey accurately`,
        tweakSection: `You are an expert heating survey assistant helping to improve survey notes.

You will receive:
- A section name (e.g., "Needs", "New boiler and controls")
- Current plainText (bullet-point style, semicolon-separated)
- Current naturalLanguage (prose description)
- User instructions on how to improve the section

Your job is to:
1. Read the current section content carefully
2. Apply the user's improvement instructions
3. Return an improved version of the section that maintains the same format

IMPORTANT RULES:
- Keep the same section name
- Maintain the plainText format (semicolon-separated bullet points)
- Maintain the naturalLanguage format (clear prose)
- Apply the user's instructions precisely
- Only modify what the user asks to improve
- Keep the technical accuracy and detail level
- Do not add information that wasn't requested
- Correct any obvious transcription errors using the context provided, especially standard pipe sizes (8/10mm, 15mm, 22mm, 28mm, 35mm) and other common measurements. Normalise improbable values to the nearest sensible standard size.

You MUST respond with ONLY valid JSON matching this shape:

{
  "section": "[section name]",
  "plainText": "Improved bullet points; separated by semicolons;",
  "naturalLanguage": "Improved prose description."
}

Do not wrap the JSON in backticks or markdown.
Do not include any explanation outside the JSON.`
        ,
        depotNotes: DEFAULT_NOTES_INSTRUCTIONS
      };
    }

    function loadAIInstructions() {
      const defaults = getDefaultAIInstructions();
      const stored = readJSONSafe(AI_INSTRUCTIONS_STORAGE_KEY);
      if (stored) {
        return {
          agentChat: stored.agentChat || defaults.agentChat,
          tweakSection: stored.tweakSection || defaults.tweakSection,
          depotNotes: stored.depotNotes || defaults.depotNotes
        };
      }

      return defaults;
    }

    function saveAIInstructions(instructions) {
      try {
        writeJSONSafe(AI_INSTRUCTIONS_STORAGE_KEY, instructions);
        document.getElementById('ai-status').textContent = "AI instructions saved to your profile";
        setTimeout(() => {
          document.getElementById('ai-status').textContent = "";
        }, 3000);
      } catch (err) {
        alert("Unable to save AI instructions: " + (err?.message || err));
      }
    }

    function renderAIInstructions() {
      const instructions = loadAIInstructions();
      const agentChatArea = document.getElementById('ai-agent-chat-instructions');
      const tweakSectionArea = document.getElementById('ai-tweak-section-instructions');
      const depotNotesArea = document.getElementById('notes-instructions');

      if (agentChatArea) {
        agentChatArea.value = instructions.agentChat;
      }
      if (tweakSectionArea) {
        tweakSectionArea.value = instructions.tweakSection;
      }
      if (depotNotesArea) {
        depotNotesArea.value = instructions.depotNotes;
      }
    }

    // AI Instructions event listeners
    document.getElementById('ai-save-btn')?.addEventListener('click', () => {
      const agentChatArea = document.getElementById('ai-agent-chat-instructions');
      const tweakSectionArea = document.getElementById('ai-tweak-section-instructions');
      const depotNotesArea = document.getElementById('notes-instructions');

      const instructions = {
        agentChat: agentChatArea?.value || getDefaultAIInstructions().agentChat,
        tweakSection: tweakSectionArea?.value || getDefaultAIInstructions().tweakSection,
        depotNotes: depotNotesArea?.value || getDefaultAIInstructions().depotNotes
      };

      saveAIInstructions(instructions);
    });

    document.getElementById('ai-reset-btn')?.addEventListener('click', () => {
      if (!confirm('Reset AI instructions to defaults? This cannot be undone.')) return;

      localStorage.removeItem(AI_INSTRUCTIONS_STORAGE_KEY);
      const scopedAIKey = getUserScopedKey(AI_INSTRUCTIONS_STORAGE_KEY);
      if (scopedAIKey) {
        localStorage.removeItem(scopedAIKey);
      }
      renderAIInstructions();
      document.getElementById('ai-status').textContent = "AI instructions reset to defaults";
      setTimeout(() => {
        document.getElementById('ai-status').textContent = "";
      }, 3000);
    });

    document.getElementById('notes-reset-btn')?.addEventListener('click', () => {
      const depotNotesArea = document.getElementById('notes-instructions');
      if (depotNotesArea) {
        depotNotesArea.value = getDefaultAIInstructions().depotNotes;
        document.getElementById('ai-status').textContent = "Notes instructions reset to recommended rules";
        setTimeout(() => {
          document.getElementById('ai-status').textContent = "";
        }, 3000);
      }
    });

    // --- Authentication and Cloud Sync ---
    async function updateAuthUI() {
      const loginBtn = document.getElementById('loginBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const userDisplay = document.getElementById('userDisplay');
      const syncToCloudBtn = document.getElementById('syncToCloudBtn');
      const syncFromCloudBtn = document.getElementById('syncFromCloudBtn');

      // Check if auth module is loaded
      if (typeof window.DepotAuth === 'undefined') {
        console.warn('DepotAuth module not loaded yet');
        return;
      }

      const isAuth = window.DepotAuth.isAuthenticated();

      if (isAuth) {
        const userInfo = window.DepotAuth.getUserInfo();
        if (userInfo) {
          userDisplay.textContent = `Signed in as ${userInfo.username}`;
          loginBtn.style.display = 'none';
          logoutBtn.style.display = 'inline-flex';
          syncToCloudBtn.disabled = false;
          syncFromCloudBtn.disabled = false;
        }
      } else {
        userDisplay.textContent = 'Not signed in';
        loginBtn.style.display = 'inline-flex';
        logoutBtn.style.display = 'none';
        syncToCloudBtn.disabled = true;
        syncFromCloudBtn.disabled = true;
      }
    }

    document.getElementById('loginBtn')?.addEventListener('click', () => {
      window.location.href = 'login.html';
    });

    document.getElementById('logoutBtn')?.addEventListener('click', () => {
      if (confirm('Sign out? Your local settings will remain on this device.')) {
        if (typeof window.DepotAuth !== 'undefined') {
          window.DepotAuth.logout();
        }
      }
    });

    document.getElementById('syncToCloudBtn')?.addEventListener('click', async () => {
      if (typeof window.DepotAuth === 'undefined') {
        alert('Authentication module not loaded');
        return;
      }

      if (!window.DepotAuth.isAuthenticated()) {
        alert('Please sign in first');
        window.location.href = 'login.html';
        return;
      }

      const btn = document.getElementById('syncToCloudBtn');
      const status = document.getElementById('syncStatus');

      btn.disabled = true;
      btn.textContent = 'Syncing...';
      status.textContent = 'Uploading settings to cloud...';

      const result = await window.DepotAuth.syncAllSettingsToCloud();

      btn.disabled = false;
      btn.textContent = '‚Üë Save to Cloud';

      if (result.success) {
        status.innerHTML = `<strong>Success!</strong> Saved ${result.saved} settings to cloud.`;
        status.classList.remove('error');
      } else {
        status.innerHTML = `<strong>Error:</strong> ${result.error}`;
        status.classList.add('error');
      }

      setTimeout(() => {
        status.textContent = '';
        status.classList.remove('error');
      }, 5000);
    });

    document.getElementById('syncFromCloudBtn')?.addEventListener('click', async () => {
      if (typeof window.DepotAuth === 'undefined') {
        alert('Authentication module not loaded');
        return;
      }

      if (!window.DepotAuth.isAuthenticated()) {
        alert('Please sign in first');
        window.location.href = 'login.html';
        return;
      }

      if (!confirm('Load settings from cloud? This will overwrite your current local settings.')) {
        return;
      }

      const btn = document.getElementById('syncFromCloudBtn');
      const status = document.getElementById('syncStatus');

      btn.disabled = true;
      btn.textContent = 'Syncing...';
      status.textContent = 'Downloading settings from cloud...';

      const result = await window.DepotAuth.syncAllSettingsFromCloud();

      btn.disabled = false;
      btn.textContent = '‚Üì Load from Cloud';

      if (result.success) {
        status.innerHTML = `<strong>Success!</strong> Loaded ${result.appliedCount} settings from cloud. <a href="#" onclick="location.reload()">Reload page</a> to see changes.`;
        status.classList.remove('error');
      } else {
        status.innerHTML = `<strong>Error:</strong> ${result.error}`;
        status.classList.add('error');
      }
    });

    // --- PWA Features ---
    function setupPWAFeatures() {
      const checkUpdatesBtn = document.getElementById('checkUpdatesBtn');
      const installAppBtn = document.getElementById('installAppBtn');
      const clearCacheBtn = document.getElementById('clearCacheBtn');
      const swStatus = document.getElementById('swStatus');

      // Check service worker status
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistration().then(registration => {
          if (registration) {
            swStatus.textContent = '‚úÖ Active';
            swStatus.style.color = 'var(--success)';
          } else {
            swStatus.textContent = '‚ùå Not registered';
            swStatus.style.color = 'var(--danger)';
          }
        });
      } else {
        swStatus.textContent = '‚ùå Not supported';
        swStatus.style.color = 'var(--danger)';
      }

      // Check for updates button
      if (checkUpdatesBtn) {
        checkUpdatesBtn.addEventListener('click', () => {
          if ('serviceWorker' in navigator && navigator.serviceWorker.ready) {
            navigator.serviceWorker.ready.then(registration => {
              if (registration && registration.update) {
                console.log('[PWA] Manual update check triggered');
                registration.update();
                alert('‚úÖ Checking for updates...\n\nIf a new version is found, the app will reload automatically.');
              }
            });
          } else {
            alert('‚ùå Service worker not available.\n\nPlease reload the page to register the service worker.');
          }
        });
      }

      // Install app button
      if (installAppBtn) {
        // Show button if install prompt is available
        window.addEventListener('beforeinstallprompt', (e) => {
          e.preventDefault();
          installAppBtn.style.display = 'inline-block';

          installAppBtn.addEventListener('click', async () => {
            if (typeof window.triggerInstallPrompt === 'function') {
              window.triggerInstallPrompt();
            } else {
              e.prompt();
              const { outcome } = await e.userChoice;
              if (outcome === 'accepted') {
                installAppBtn.style.display = 'none';
              }
            }
          });
        });

        // Check if already installed
        if (window.matchMedia('(display-mode: standalone)').matches) {
          installAppBtn.textContent = '‚úÖ App Installed';
          installAppBtn.disabled = true;
        }
      }

      // Clear cache button
      if (clearCacheBtn) {
        clearCacheBtn.addEventListener('click', () => {
          if (typeof window.clearAppCache === 'function') {
            window.clearAppCache();
          } else if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            if (confirm('üßπ Clear all cached data?\n\nThis will free up space but may slow down the app temporarily.')) {
              navigator.serviceWorker.controller.postMessage({ type: 'CLEAR_CACHE' });
              alert('‚úÖ Cache cleared! The app will reload...');
              setTimeout(() => window.location.reload(), 1000);
            }
          } else {
            alert('‚ùå Service worker not available.\n\nPlease reload the page to register the service worker.');
          }
        });
      }
    }

    // --- Voice Notes 2.0 Settings ---
    function loadVoiceNotes2Settings() {
      const skipClarification = localStorage.getItem('depot.skipClarificationModal') === 'true';
      const enableMultipleQuotes = localStorage.getItem('depot.enableMultipleQuotesDetection') !== 'false'; // Default to true

      const skipCheckbox = document.getElementById('skipClarificationModal');
      const multipleQuotesCheckbox = document.getElementById('enableMultipleQuotesDetection');

      if (skipCheckbox) {
        skipCheckbox.checked = skipClarification;
        skipCheckbox.addEventListener('change', (e) => {
          localStorage.setItem('depot.skipClarificationModal', e.target.checked ? 'true' : 'false');
        });
      }

      if (multipleQuotesCheckbox) {
        multipleQuotesCheckbox.checked = enableMultipleQuotes;
        multipleQuotesCheckbox.addEventListener('change', (e) => {
          localStorage.setItem('depot.enableMultipleQuotesDetection', e.target.checked ? 'true' : 'false');
        });
      }
    }

    function renderBuildMeta() {
      const appVariationValue = document.getElementById('appVariationValue');
      const cacheVariationValue = document.getElementById('cacheVariationValue');
      const workerEndpointValue = document.getElementById('workerEndpointValue');

      const buildInfo = window.DepotBuildInfo || {};
      const appVersion = buildInfo.appVersion || '1.2.0';
      const cacheVersion = buildInfo.cacheVersion || 'depot-v1.2.0';
      const workerUrl = (window.DepotWorkerConfig?.getWorkerUrl?.())
        || localStorage.getItem('depot.workerUrl')
        || localStorage.getItem('depot-worker-url')
        || 'https://depot-voice-notes.martinbibb.workers.dev';

      if (appVariationValue) {
        appVariationValue.textContent = appVersion;
      }
      if (cacheVariationValue) {
        cacheVariationValue.textContent = cacheVersion;
      }
      if (workerEndpointValue) {
        workerEndpointValue.textContent = workerUrl.replace(/^https?:\/\//, '');
        workerEndpointValue.title = workerUrl;
      }
    }

    // --- Boot ---
    (async function boot() {
      await loadSections();
      loadSectionRules();
      await loadChecklist();
      loadExportFormat();
      renderAIInstructions();
      loadVoiceNotes2Settings();
      renderBuildMeta();

      // Load auth module dynamically
      try {
        await import('./src/auth/auth-client.js');
        updateAuthUI();
      } catch (err) {
        console.warn('Failed to load auth module:', err);
      }

      // PWA features setup
      setupPWAFeatures();

      // Load setup wizard module
      try {
        const wizardModule = await import('./js/setupWizard.js');

        // Setup wizard button click handler
        document.getElementById('openSetupWizardBtn')?.addEventListener('click', () => {
          wizardModule.showSetupWizard();
        });
      } catch (err) {
        console.warn('Failed to load setup wizard module:', err);
      }
    })();
  </script>

  <!-- Service Worker Registration (shared with main app) -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => {
            console.log('‚úÖ Service Worker registered:', registration.scope);
          })
          .catch(error => {
            console.error('‚ùå Service Worker registration failed:', error);
          });
      });

      // Reload the page once when a new service worker takes control
      let hasReloadedForSWUpdate = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        // Avoid potential infinite reload loops
        if (hasReloadedForSWUpdate) return;
        hasReloadedForSWUpdate = true;

        console.log('[PWA] New version activated ‚Äì reloading to apply updates');
        window.location.reload();
      });
    }
  </script>
</body>
</html>
