<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Survey Brain – Live Depot Notes</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #eef2f7;
      --card: #ffffff;
      --border: #d4dbe5;
      --accent: #0f766e;
      --accent-soft: #14b8a6;
      --muted: #64748b;
      --danger: #b91c1c;
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #0f172a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      background: #0f172a;
      color: #fff;
      padding: 14px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    header h1 { margin: 0; font-size: 1.05rem; }
    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-left: auto;
    }
    main {
      padding: 14px;
      display: grid;
      grid-template-columns: 1.1fr .9fr;
      grid-template-areas: "left right";
      gap: 14px;
    }
    @media (max-width: 970px) {
      main {
        grid-template-columns: 1fr;
        grid-template-areas:
          "left"
          "right";
      }
    }
    .main-left { grid-area: left; }
    .main-right { grid-area: right; }
    .column { display: flex; flex-direction: column; gap: 14px; }
    .results-row {
      padding: 0 14px 14px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px 14px 10px;
    }
    .card-title {
      font-size: .75rem;
      text-transform: uppercase;
      letter-spacing: .03em;
      font-weight: 600;
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: baseline;
    }
    .small { font-size: .68rem; color: var(--muted); }
    textarea {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #cbd5e1;
      padding: 8px 9px;
      font-size: .75rem;
      min-height: 120px;
    }
    button {
      border: none;
      background: var(--accent);
      color: #fff;
      border-radius: 999px;
      padding: 6px 14px 6px;
      font-size: .7rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }
    button:disabled { opacity: .55; cursor: default; }
    .pill-secondary {
      background: rgba(148,163,184,.16);
      color: #e2e8f0;
    }
    .pill-danger {
      background: var(--danger);
    }
    .clarifications {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex-wrap: nowrap;
    }
    .clar-chip {
      background: #ecfeff;
      border: 1px solid #cffafe;
      border-radius: 12px;
      padding: 5px 10px 6px;
      font-size: .65rem;
    }
    .clar-chip[data-target="engineer"] {
      background: #fef9c3;
      border-color: #fde68a;
    }
    .sections-list { display: flex; flex-direction: column; gap: 7px; }
    .section-item {
      background: #f8fafc;
      border-radius: 12px;
      border: 1px solid rgba(100,116,139,.06);
      padding: 6px 8px 6px;
    }
    .section-item h4 {
      margin: 0 0 3px;
      font-size: .7rem;
    }
    .section-item pre {
      margin: 0;
      white-space: pre-wrap;
      font-size: .64rem;
    }
    .statusbar {
      font-size: .6rem;
      color: var(--muted);
      margin-top: 4px;
    }
    .check-group-title {
      margin: 6px 0 2px;
      font-size: .72rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .04em;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
    }
    .check-group-title span {
      font-weight: 500;
      font-size: .64rem;
    }
    .checklist-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 4px 8px 5px;
    }
    .checklist-item .icon {
      font-size: .8rem;
      line-height: 1.2;
    }
    .checklist-item .label {
      font-size: .7rem;
    }
    .checklist-item .hint {
      display: block;
      font-size: .62rem;
      color: var(--muted);
    }
    .checklist-item.done {
      background: #ecfdf3;
      border-color: #bbf7d0;
    }
    #voice-error {
      display: none;
      color: #b91c1c;
      font-weight: 600;
      margin: 0.5rem 1rem;
      font-size: .7rem;
    }
    /* Settings overlay */
    .settings-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    .settings-panel {
      background: #0b1120;
      color: #e5e7eb;
      border-radius: 18px;
      padding: 16px 16px 12px;
      max-width: 960px;
      width: calc(100% - 24px);
      max-height: calc(100% - 24px);
      overflow: auto;
      box-shadow: 0 20px 40px rgba(15,23,42,.65);
      font-size: .75rem;
    }
    .settings-panel h2 {
      margin: 0 0 6px;
      font-size: .9rem;
    }
    .settings-panel textarea {
      width: 100%;
      min-height: 140px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: .7rem;
      background: #020617;
      color: #e5e7eb;
      border-radius: 10px;
      border: 1px solid #1e293b;
    }
    .settings-panel .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 900px) {
      .settings-panel .row {
        grid-template-columns: 1fr;
      }
    }
    .pill-muted {
      background: rgba(148,163,184,.16);
      border-radius: 999px;
      padding: 3px 9px;
      font-size: .65rem;
      color: #94a3b8;
    }
  </style>
</head>
<body>
  <header>
    <h1>Survey Brain</h1>
    <div class="toolbar-row">
      <button id="sendTextBtn">Send text</button>
      <button id="startLiveBtn">Start live</button>
      <button id="pauseLiveBtn" class="pill-secondary" disabled>Pause</button>
      <button id="finishLiveBtn" class="pill-secondary" disabled>Finish</button>
      <button id="importAudioBtn" class="pill-secondary">Use audio file</button>
      <button id="exportBtn" class="pill-secondary">Send notes</button>
      <button id="saveSessionBtn" class="pill-secondary">Save session</button>
      <button id="loadSessionBtn" class="pill-secondary">Load session</button>
      <button id="settingsBtn" class="pill-secondary">Settings</button>
    </div>
  </header>

  <div id="voice-error"></div>

  <main>
    <!-- LEFT: transcript + customer summary -->
    <div class="column main-left">
      <div class="card">
        <div class="card-title">
          Live transcript / summary
          <span class="small">You talk to customer • system listens</span>
        </div>
        <textarea id="transcriptInput" placeholder="Replace existing combi in the same place, fit Hive, reuse flue where possible..."></textarea>

        <div class="statusbar" id="statusBar">Idle (Online • Manual)</div>
      </div>

      <div class="card">
        <div class="card-title">
          Customer summary
          <span class="small">Show this to customer</span>
        </div>
        <p id="customerSummary" class="small">(none)</p>
      </div>
    </div>

    <!-- RIGHT: checklist + parts -->
    <div class="column main-right">
      <div class="card">
        <div class="card-title">
          Survey checklist &amp; questions
          <span class="small">Ticks as details are captured</span>
        </div>
        <div id="clarifications" class="clarifications">
          <span class="small">No checklist items yet.</span>
        </div>
      </div>

      <div class="card">
        <div class="card-title">
          Suggested parts list
          <span class="small">Draft list – refine before quoting</span>
        </div>
        <div id="partsList">
          <span class="small">No suggestions yet.</span>
        </div>
      </div>
    </div>
  </main>

  <!-- BOTTOM: depot results full width -->
  <section class="results-row">
    <div class="card">
      <div class="card-title">
        Depot sections so far
        <span class="small">Standard layout</span>
      </div>
      <div id="sectionsList" class="sections-list">
        <span class="small">No sections yet.</span>
      </div>
    </div>
  </section>

  <!-- File inputs -->
  <input id="loadSessionInput" type="file" accept=".depotvoice.json,application/json" style="display:none;">
  <input id="importAudioInput" type="file" accept="audio/*" style="display:none;">

  <!-- Settings overlay -->
  <div id="settingsOverlay" class="settings-overlay">
    <div class="settings-panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
        <div>
          <h2>Survey Brain Settings</h2>
          <div class="small">Edit how sections and checklist items behave on this device.</div>
        </div>
        <button id="closeSettingsBtn" class="pill-secondary">Close</button>
      </div>
      <div class="row">
        <section>
          <h3>Depot section schema</h3>
          <p class="small">Controls section names and ordering. Each entry needs <code>name</code> and optional <code>description</code>.</p>
          <textarea id="schemaEditor"></textarea>
          <div style="margin-top:6px;display:flex;gap:6px;">
            <button id="schemaSaveBtn">Save schema (local)</button>
            <button id="schemaResetBtn" class="pill-secondary">Reset to defaults</button>
          </div>
        </section>
        <section>
          <h3>Checklist items</h3>
          <p class="small">List of survey checklist items the AI can tick (id, group, section, label, hint).</p>
          <textarea id="checklistEditor"></textarea>
          <div style="margin-top:6px;display:flex;gap:6px;">
            <button id="checklistSaveBtn">Save checklist (local)</button>
            <button id="checklistResetBtn" class="pill-secondary">Reset to defaults</button>
          </div>
        </section>
      </div>
      <p class="small" style="margin-top:8px;">
        <span class="pill-muted">Note</span> Changes are stored in this browser only (localStorage).  
        To ship new defaults for everyone, update <code>depot.output.schema.json</code> and <code>checklist.config.json</code> in the repo.
      </p>
    </div>
  </div>

  <script>
    // --- CONFIG: worker endpoint ---
    const WORKER_URL = "https://depot-voice-notes.martinbibb.workers.dev";

    // --- ELEMENTS ---
    const sendTextBtn = document.getElementById("sendTextBtn");
    const transcriptInput = document.getElementById("transcriptInput");
    const customerSummaryEl = document.getElementById("customerSummary");
    const clarificationsEl = document.getElementById("clarifications");
    const sectionsListEl = document.getElementById("sectionsList");
    const statusBar = document.getElementById("statusBar");
    const startLiveBtn = document.getElementById("startLiveBtn");
    const pauseLiveBtn = document.getElementById("pauseLiveBtn");
    const finishLiveBtn = document.getElementById("finishLiveBtn");
    const exportBtn = document.getElementById("exportBtn");
    const saveSessionBtn = document.getElementById("saveSessionBtn");
    const loadSessionBtn = document.getElementById("loadSessionBtn");
    const loadSessionInput = document.getElementById("loadSessionInput");
    const importAudioBtn = document.getElementById("importAudioBtn");
    const importAudioInput = document.getElementById("importAudioInput");
    const partsListEl = document.getElementById("partsList");
    const voiceErrorEl = document.getElementById("voice-error");
    const settingsBtn = document.getElementById("settingsBtn");
    const settingsOverlay = document.getElementById("settingsOverlay");
    const closeSettingsBtn = document.getElementById("closeSettingsBtn");
    const schemaEditor = document.getElementById("schemaEditor");
    const checklistEditor = document.getElementById("checklistEditor");
    const schemaSaveBtn = document.getElementById("schemaSaveBtn");
    const schemaResetBtn = document.getElementById("schemaResetBtn");
    const checklistSaveBtn = document.getElementById("checklistSaveBtn");
    const checklistResetBtn = document.getElementById("checklistResetBtn");

    // --- STATE ---
    let lastMaterials = [];
    let lastRawSections = [];
    let lastSections = [];
    let lastCheckedItems = [];
    let lastMissingInfo = [];
    let lastCustomerSummary = "";
    let SECTION_SCHEMA = [];
    let SECTION_ORDER = {};
    let CHECKLIST_SOURCE = [];
    let CHECKLIST_ITEMS = [];

    // Live session speech state
    const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition || null;
    let recognition = null;
    let liveState = "idle"; // idle | running | paused
    let recognitionActive = false;
    let shouldRestartRecognition = false;
    let recognitionStopMode = null; // null | "pause" | "finish"
    let committedTranscript = "";
    let interimTranscript = "";
    let lastSentTranscript = "";
    let chunkTimerId = null;
    const LIVE_CHUNK_INTERVAL_MS = 20000;
    let pendingFinishSend = false;

    // --- LOCALSTORAGE KEYS ---
    const LS_SCHEMA_KEY = "surveybrain-schema";
    const LS_CHECKLIST_KEY = "surveybrain-checklist";

    // --- HELPERS ---
    function showVoiceError(message) {
      if (!voiceErrorEl) {
        console.error("Voice error:", message);
        alert(message);
        return;
      }
      voiceErrorEl.textContent = message;
      voiceErrorEl.style.display = "block";
    }
    function clearVoiceError() {
      if (!voiceErrorEl) return;
      voiceErrorEl.textContent = "";
      voiceErrorEl.style.display = "none";
    }
    function currentModeLabel() {
      return liveState === "running" || liveState === "paused" ? "Live" : "Manual";
    }
    function setStatus(msg) {
      const onlinePart = navigator.onLine ? "Online" : "Offline";
      statusBar.textContent = `${msg || "Idle"} (${onlinePart} • ${currentModeLabel()})`;
    }
    function cloneDeep(val) {
      try { return JSON.parse(JSON.stringify(val)); } catch (_) { return val; }
    }

    async function postJSON(path, body) {
      const base = WORKER_URL.replace(/\/$/, "");
      const url = base + path;
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      return res;
    }

    // --- SECTION / SCHEMA LOADING & NORMALISATION ---
    const SECTION_FALLBACK = [
      { name: "Needs", order: 1, description: "Key needs or must-haves called out by the customer." },
      { name: "Working at heights", order: 2, description: "Ladders, loft access, towers, scaffolds or special access kit." },
      { name: "System characteristics", order: 3, description: "Existing system, proposed boiler, cylinders and storage." },
      { name: "Components that require assistance", order: 4, description: "Items needing two-person lifts or specialist handling." },
      { name: "Restrictions to work", order: 5, description: "Parking limits, permits or building restrictions." },
      { name: "External hazards", order: 6, description: "Asbestos, hazards, aggressive pets or notable site risks." },
      { name: "Delivery notes", order: 7, description: "Delivery constraints, storage space and timings." },
      { name: "Office notes", order: 8, description: "For the office team: planning, conservation, notifications." },
      { name: "New boiler and controls", order: 9, description: "What is being fitted: boiler, controls, flushing, filters." },
      { name: "Flue", order: 10, description: "Flue position, routing, plume kits and terminals." },
      { name: "Pipe work", order: 11, description: "Gas, condensate and system pipe alterations." },
      { name: "Disruption", order: 12, description: "Power flush, draining, floor lifting or decorations impacted." },
      { name: "Customer actions", order: 13, description: "Things the customer has to sort before install." },
      { name: "Future plans", order: 14, description: "Customer’s future plans or potential upgrades." }
    ];

    function normaliseSectionSchema(entries) {
      if (entries && typeof entries === "object" && !Array.isArray(entries) && Array.isArray(entries.sections)) {
        return normaliseSectionSchema(entries.sections);
      }
      if (!Array.isArray(entries)) return [];
      return entries.map((entry, idx) => {
        if (!entry) return null;
        if (typeof entry === "string") {
          const name = entry.trim();
          if (!name) return null;
          return { name, order: idx + 1, description: "" };
        }
        const name = String(entry.name || entry.section || "").trim();
        if (!name) return null;
        const order = typeof entry.order === "number" ? entry.order : idx + 1;
        const description = String(entry.description || entry.hint || "").trim();
        return { name, order, description };
      }).filter(Boolean);
    }

    function applySectionSchema(entries) {
      const normalised = normaliseSectionSchema(entries);
      const fallback = normalised.length ? normalised : normaliseSectionSchema(SECTION_FALLBACK);
      SECTION_SCHEMA = fallback;
      SECTION_ORDER = {};
      fallback.forEach((sec, idx) => {
        const order = typeof sec.order === "number" ? sec.order : idx + 1;
        SECTION_ORDER[sec.name] = order;
      });
    }

    function normaliseChecklistConfig(items) {
      if (items && typeof items === "object" && !Array.isArray(items) && Array.isArray(items.items)) {
        return normaliseChecklistConfig(items.items);
      }
      if (!Array.isArray(items)) return [];
      return items.map(item => {
        if (!item) return null;
        const id = item.id != null ? String(item.id).trim() : "";
        if (!id) return null;
        return {
          id,
          group: item.group || item.category || "Checklist",
          section: item.section || item.sectionName || "",
          label: item.label || item.name || id,
          hint: item.hint || item.description || ""
        };
      }).filter(Boolean);
    }

    function deriveSectionHints() {
      const hints = {};
      const addHint = (rawKey, sectionName) => {
        const key = typeof rawKey === "string" ? rawKey.trim().toLowerCase() : String(rawKey || "").trim().toLowerCase();
        const section = typeof sectionName === "string" ? sectionName.trim() : String(sectionName || "").trim();
        if (!key || !section || hints[key]) return;
        hints[key] = section;
      };

      SECTION_SCHEMA.forEach(sec => {
        if (!sec || !sec.name) return;
        addHint(sec.name, sec.name);
        const tokens = String(sec.name)
          .toLowerCase()
          .split(/[^a-z0-9]+/)
          .map(t => t.trim())
          .filter(t => t.length >= 3);
        tokens.forEach(token => addHint(token, sec.name));
      });

      CHECKLIST_ITEMS.forEach(item => {
        if (!item) return;
        const sectionName = (item.section || "").trim();
        if (!sectionName) return;
        addHint(item.id, sectionName);
        const textBits = [item.label || "", item.hint || ""]
          .join(" ")
          .toLowerCase()
          .split(/[^a-z0-9]+/)
          .map(t => t.trim())
          .filter(t => t.length >= 3);
        textBits.forEach(token => addHint(token, sectionName));
      });

      return hints;
    }

    function buildVoiceRequestPayload(transcript) {
      const existingSections = Array.isArray(lastRawSections)
        ? lastRawSections
            .map(sec => {
              if (!sec || typeof sec !== "object") return null;
              const section = typeof sec.section === "string" ? sec.section.trim() : String(sec.section || "").trim();
              if (!section) return null;
              return {
                section,
                plainText: typeof sec.plainText === "string" ? sec.plainText : String(sec.plainText || ""),
                naturalLanguage: typeof sec.naturalLanguage === "string" ? sec.naturalLanguage : String(sec.naturalLanguage || "")
              };
            })
            .filter(Boolean)
        : [];

      const expectedSections = Array.isArray(SECTION_SCHEMA)
        ? SECTION_SCHEMA
            .map(sec => (sec && sec.name ? String(sec.name).trim() : ""))
            .filter(Boolean)
        : [];

      return {
        transcript,
        alreadyCaptured: existingSections,
        expectedSections,
        sectionHints: deriveSectionHints(),
        forceStructured: true,
        checklistItems: CHECKLIST_SOURCE,
        depotSections: SECTION_SCHEMA
      };
    }

    // Plaintext shaping helpers
    function ensureSemi(s){ s=String(s||"").trim(); return s ? (s.endsWith(";")?s:s+";") : s; }
    function splitClauses(text){
      return String(text||"")
        .split(/[\n;]+/)
        .map(s => s.trim())
        .filter(Boolean);
    }
    function stripPreamble(line){
      let s = String(line||"").trim();
      s = s
        .replace(/^(then|next|first|second|after|before|finally|so)\b[:,\s-]*/i, "")
        .replace(/^(we(?:'|’)ll|we will|i(?:'|’)ll|engineer will|installer will|we need to|need to|we can|we should)\b[:,\s-]*/i, "")
        .replace(/^(please|note|recommended to)\b[:,\s-]*/i, "");
      s = s.replace(/\bwill need to\b/gi, "required to");
      return s.trim();
    }
    function bulletify(lines){
      const out=[];
      for (let raw of lines){
        const t = stripPreamble(raw);
        if (!t) continue;
        out.push("• " + ensureSemi(t));
      }
      return out.join("\n");
    }
    function formatPlainTextForSection(section, plain){
      if (!plain) return "";
      return bulletify(splitClauses(plain));
    }

    function renderPartsList(materials) {
      lastMaterials = Array.isArray(materials) ? materials.slice() : [];
      if (!partsListEl) return;
      partsListEl.innerHTML = "";
      if (!lastMaterials.length) {
        partsListEl.innerHTML = `<span class="small">No suggestions yet.</span>`;
        return;
      }
      const byCategory = new Map();
      lastMaterials.forEach(item => {
        const cat = item.category || "Misc";
        const arr = byCategory.get(cat) || [];
        arr.push(item);
        byCategory.set(cat, arr);
      });
      byCategory.forEach((items, cat) => {
        const h = document.createElement("div");
        h.className = "small";
        h.style.fontWeight = "600";
        h.style.margin = "4px 0 2px";
        h.textContent = cat;
        partsListEl.appendChild(h);
        const ul = document.createElement("ul");
        ul.style.margin = "0 0 4px 14px";
        ul.style.padding = "0";
        ul.style.listStyle = "disc";
        items.forEach(p => {
          const li = document.createElement("li");
          li.style.fontSize = ".68rem";
          const detail = [];
          if (p.item) detail.push(p.item);
          if (p.qty && Number(p.qty) !== 1) detail.push(`× ${p.qty}`);
          if (p.notes) detail.push(p.notes);
          li.textContent = detail.length ? detail.join(" — ") : (p.item || "Item");
          ul.appendChild(li);
        });
        partsListEl.appendChild(ul);
      });
    }

    function postProcessSections(sections) {
      const out = [];
      sections.forEach(sec => {
        if (!sec || !sec.section) return;
        out.push({
          section: sec.section,
          plainText: sec.plainText || "",
          naturalLanguage: sec.naturalLanguage || ""
        });
      });
      out.sort((a,b) => {
        const oa = SECTION_ORDER[a.section] || 999;
        const ob = SECTION_ORDER[b.section] || 999;
        return oa - ob;
      });
      out.forEach(sec => {
        if (sec.plainText) sec.plainText = formatPlainTextForSection(sec.section, sec.plainText);
      });
      return out;
    }

    function renderChecklist(container, checkedIds, missingInfoFromServer) {
      const checkedSet = new Set((checkedIds || []).map(String));
      const questions = Array.isArray(missingInfoFromServer) ? missingInfoFromServer : [];
      container.innerHTML = "";

      if (!CHECKLIST_ITEMS.length && !checkedSet.size && !questions.length) {
        container.innerHTML = `<span class="small">No checklist items.</span>`;
        return;
      }

      const byGroup = new Map();
      const knownIds = new Set();
      CHECKLIST_ITEMS.forEach(item => {
        const group = item.group || "Checklist";
        const arr = byGroup.get(group) || [];
        knownIds.add(String(item.id));
        arr.push({
          id: item.id,
          section: item.section || "",
          label: item.label || item.id,
          hint: item.hint || "",
          done: checkedSet.has(String(item.id))
        });
        byGroup.set(group, arr);
      });

      const unknownFromAi = Array.from(checkedSet).filter(id => id && !knownIds.has(id));
      if (unknownFromAi.length) {
        const arr = unknownFromAi.map(id => ({
          id,
          section: "",
          label: String(id),
          hint: "",
          done: true
        }));
        byGroup.set("Other (from AI)", arr);
      }

      if (!byGroup.size && !questions.length) {
        container.innerHTML = `<span class="small">No checklist items.</span>`;
        return;
      }

      [...byGroup.entries()].forEach(([groupName, items]) => {
        const header = document.createElement("div");
        header.className = "check-group-title";
        header.innerHTML = `<span>${groupName}</span><span>${items[0].section || ""}</span>`;
        container.appendChild(header);

        items.forEach(item => {
          const div = document.createElement("div");
          div.className = "clar-chip checklist-item" + (item.done ? " done" : "");
          div.innerHTML = `
            <span class="icon">${item.done ? "✅" : "⭕"}</span>
            <span class="label">
              ${item.label}
              <span class="hint">
                ${item.hint || ""}
                ${item.section ? ` • <strong>${item.section}</strong>` : ""}
              </span>
            </span>
          `;
          container.appendChild(div);
        });
      });

      if (questions.length) {
        const sep = document.createElement("div");
        sep.className = "small";
        sep.style.marginTop = "6px";
        sep.textContent = "Additional questions:";
        container.appendChild(sep);
        questions.forEach(q => {
          const div = document.createElement("div");
          div.className = "clar-chip";
          div.dataset.target = q.target || "engineer";
          div.innerHTML = `<strong>${q.target || "engineer"}:</strong> ${q.question}`;
          container.appendChild(div);
        });
      }
    }

    function refreshUiFromState() {
      customerSummaryEl.textContent = lastCustomerSummary || "(none)";
      const processed = postProcessSections(cloneDeep(lastRawSections || []));
      lastSections = processed;
      sectionsListEl.innerHTML = "";
      if (processed.length) {
        processed.forEach(sec => {
          const div = document.createElement("div");
          div.className = "section-item";
          div.innerHTML = `
            <h4>${sec.section}</h4>
            <pre>${sec.plainText || ""}</pre>
            <p class="small" style="margin-top:3px;">${sec.naturalLanguage || ""}</p>
          `;
          sectionsListEl.appendChild(div);
        });
      } else {
        sectionsListEl.innerHTML = `<span class="small">No sections yet.</span>`;
      }
      renderPartsList(lastMaterials);
      renderChecklist(clarificationsEl, lastCheckedItems, lastMissingInfo);
    }

    function applyVoiceResult(result) {
      if (!result || typeof result !== "object") {
        showVoiceError("AI gave an empty result.");
        return;
      }

      const prevSections = cloneDeep(lastRawSections || []);
      const prevMaterials = Array.isArray(lastMaterials) ? lastMaterials.slice() : [];
      const prevSummary = lastCustomerSummary;
      const prevChecked = Array.isArray(lastCheckedItems) ? lastCheckedItems.slice() : [];
      const prevMissing = Array.isArray(lastMissingInfo) ? lastMissingInfo.slice() : [];

      let updated = false;

      const sectionsCandidateRaw = Array.isArray(result.sections)
        ? result.sections
        : (result.depotNotes && Array.isArray(result.depotNotes.sections))
          ? result.depotNotes.sections
          : [];
      const sectionsCandidate = Array.isArray(sectionsCandidateRaw) ? sectionsCandidateRaw : [];

      if (sectionsCandidate.length) {
        lastRawSections = cloneDeep(sectionsCandidate);
        updated = true;
      } else {
        lastRawSections = prevSections;
      }

      if (Array.isArray(result.materials) && result.materials.length) {
        lastMaterials = result.materials.slice();
        updated = true;
      } else if (result.materials === undefined) {
        lastMaterials = prevMaterials;
      } else {
        lastMaterials = prevMaterials;
      }

      if (Array.isArray(result.checkedItems)) {
        lastCheckedItems = result.checkedItems.slice();
      } else if (result.checkedItems === undefined) {
        lastCheckedItems = prevChecked;
      }

      if (Array.isArray(result.missingInfo)) {
        lastMissingInfo = result.missingInfo.slice();
      } else if (result.missingInfo === undefined) {
        lastMissingInfo = prevMissing;
      }

      const summaryCandidate =
        typeof result.customerSummary === "string"
          ? result.customerSummary
          : typeof result.summary === "string"
            ? result.summary
            : null;
      if (summaryCandidate !== null) {
        lastCustomerSummary = summaryCandidate;
        updated = true;
      } else {
        lastCustomerSummary = prevSummary;
      }

      if (updated) {
        clearVoiceError();
      } else {
        const hasMaterials = Array.isArray(result.materials)
          ? result.materials.length > 0
          : !!result.materials;
        if (!sectionsCandidate.length && !hasMaterials) {
          showVoiceError("AI didn’t return any depot notes. Existing notes kept.");
        }
      }

      refreshUiFromState();
    }

    async function sendText() {
      const transcript = transcriptInput.value.trim();
      if (!transcript) return;
      setStatus("Sending text…");
      clearVoiceError();
      try {
        const res = await postJSON("/text", buildVoiceRequestPayload(transcript));
        const raw = await res.text();
        if (!res.ok) {
          const snippet = raw ? `: ${raw.slice(0, 200)}` : "";
          throw new Error(`Worker error ${res.status} ${res.statusText}${snippet}`);
        }
        let data;
        try {
          data = JSON.parse(raw);
        } catch (e) {
          console.error("Voice worker returned non-JSON:", raw);
          const parseError = new Error("AI response wasn't in the expected format. Please try again.");
          parseError.voiceMessage = parseError.message;
          throw parseError;
        }
        applyVoiceResult(data);
        setStatus("Done.");
        committedTranscript = transcript;
        lastSentTranscript = transcript;
      } catch (err) {
        console.error(err);
        const message = err && err.voiceMessage
          ? err.voiceMessage
          : "Voice AI failed: " + (err && err.message ? err.message : "Unknown error");
        showVoiceError(message);
        setStatus("Text send failed.");
      }
    }

    async function sendAudio(blob) {
      setStatus("Uploading audio…");
      clearVoiceError();
      try {
        const res = await fetch(WORKER_URL.replace(/\/$/, "") + "/audio", {
          method: "POST",
          headers: { "Content-Type": blob.type || "audio/webm" },
          body: blob
        });
        const raw = await res.text();
        if (!res.ok) {
          const snippet = raw ? `: ${raw.slice(0, 200)}` : "";
          throw new Error(`Worker error ${res.status} ${res.statusText}${snippet}`);
        }
        let data;
        try {
          data = JSON.parse(raw);
        } catch (e) {
          console.error("Voice worker returned non-JSON:", raw);
          const parseError = new Error("AI response wasn't in the expected format. Please try again.");
          parseError.voiceMessage = parseError.message;
          throw parseError;
        }
        applyVoiceResult(data);
        setStatus("Audio processed.");
      } catch (err) {
        console.error(err);
        const message = err && err.voiceMessage
          ? err.voiceMessage
          : "Voice AI failed: " + (err && err.message ? err.message : "Unknown error");
        showVoiceError(message);
        setStatus("Audio failed.");
        throw err;
      }
    }

    // --- EXPORT / SESSION / AUDIO IMPORT ---
    exportBtn.onclick = async () => {
      setStatus("Preparing notes…");
      const payload = {
        exportedAt: new Date().toISOString(),
        sections: lastSections || []
      };
      const pretty = JSON.stringify(payload, null, 2);
      const blob = new Blob([pretty], { type: "application/json" });
      const defaultName = "depot-notes";
      const userName = prompt("File name (without extension):", defaultName);
      if (userName === null) {
        setStatus("Export cancelled.");
        return;
      }
      const safeName = (userName || defaultName).replace(/[^a-z0-9_\-]+/gi, "-");
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `${safeName}-${timestamp}.json`;
      const fileForShare = new File([blob], filename, { type: "application/json" });
      if (navigator.canShare && navigator.canShare({ files: [fileForShare] })) {
        try {
          await navigator.share({ files: [fileForShare] });
          setStatus("Notes shared.");
          return;
        } catch (err) {
          console.error("Share failed", err);
        }
      }
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      setStatus("Notes downloaded.");
    };

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result.split(",")[1] || "");
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    function base64ToBlob(b64, mime) {
      const byteChars = atob(b64);
      const byteNums = new Array(byteChars.length);
      for (let i = 0; i < byteChars.length; i++) {
        byteNums[i] = byteChars.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNums);
      return new Blob([byteArray], { type: mime || "application/octet-stream" });
    }

    async function saveSessionToFile() {
      const fullTranscript = transcriptInput.value.trim();
      if (!fullTranscript) {
        alert("No transcript yet.");
        return;
      }
      const session = {
        version: 1,
        createdAt: new Date().toISOString(),
        fullTranscript,
        sections: lastRawSections,
        materials: lastMaterials,
        checkedItems: lastCheckedItems,
        missingInfo: lastMissingInfo,
        customerSummary: lastCustomerSummary
      };
      const jsonStr = JSON.stringify(session, null, 2);
      const fileBlob = new Blob([jsonStr], { type: "application/json" });
      const defaultName = "depot-voice-session";
      const userName = prompt("Session file name (without extension):", defaultName);
      if (userName === null) return;
      const safeName = (userName || defaultName).replace(/[^a-z0-9_\-]+/gi, "-");
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `${safeName}-${ts}.depotvoice.json`;
      const url = URL.createObjectURL(fileBlob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    saveSessionBtn.onclick = saveSessionToFile;

    importAudioBtn.onclick = () => importAudioInput.click();
    importAudioInput.onchange = async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        await sendAudio(file);
      } catch (_) {}
      importAudioInput.value = "";
    };

    loadSessionBtn.onclick = () => loadSessionInput.click();
    loadSessionInput.onchange = async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const session = JSON.parse(text);
        transcriptInput.value = session.fullTranscript || "";
        committedTranscript = transcriptInput.value.trim();
        lastSentTranscript = committedTranscript;
        lastRawSections = Array.isArray(session.sections) ? session.sections : [];
        lastMaterials = Array.isArray(session.materials) ? session.materials : [];
        lastCheckedItems = Array.isArray(session.checkedItems) ? session.checkedItems : [];
        lastMissingInfo = Array.isArray(session.missingInfo) ? session.missingInfo : [];
        lastCustomerSummary = session.customerSummary || "";
        refreshUiFromState();
        setStatus("Session loaded.");
      } catch (err) {
        console.error(err);
        showVoiceError("Could not load session file: " + (err.message || "Unknown error"));
      } finally {
        loadSessionInput.value = "";
      }
    };

    // --- LIVE SPEECH (on-device) ---
    function updateTextareaFromBuffers() {
      const committed = committedTranscript.trim();
      const interim = interimTranscript.trim();
      const parts = [];
      if (committed) parts.push(committed);
      if (interim) parts.push(interim);
      const combined = parts.join(parts.length > 1 ? " " : "");
      transcriptInput.value = combined.trim();
    }

    function updateLiveControls() {
      if (!startLiveBtn || !pauseLiveBtn || !finishLiveBtn) return;
      if (!SpeechRec || !recognition) {
        startLiveBtn.disabled = true;
        pauseLiveBtn.disabled = true;
        finishLiveBtn.disabled = true;
        pauseLiveBtn.textContent = "Pause";
        return;
      }
      const running = liveState === "running";
      const paused = liveState === "paused";
      startLiveBtn.disabled = running || paused;
      pauseLiveBtn.disabled = liveState === "idle";
      finishLiveBtn.disabled = liveState === "idle";
      pauseLiveBtn.textContent = paused ? "Resume" : "Pause";
    }

    async function completeLiveSessionIfNeeded(message = "Live session finished.") {
      if (!pendingFinishSend) return;
      pendingFinishSend = false;
      committedTranscript = transcriptInput.value.trim();
      const ok = await sendTranscriptChunkToWorker(true);
      if (ok) {
        setStatus(message);
      }
    }

    if (SpeechRec) {
      recognition = new SpeechRec();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = "en-GB";

      recognition.onstart = () => {
        recognitionActive = true;
      };

      recognition.onresult = (event) => {
        let sawFinal = false;
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const r = event.results[i];
          if (!r || !r[0]) continue;
          const text = r[0].transcript ? r[0].transcript.trim() : "";
          if (!text) continue;
          if (r.isFinal) {
            committedTranscript = committedTranscript
              ? `${committedTranscript} ${text}`.replace(/\s+/g, " ").trim()
              : text;
            interimTranscript = "";
            sawFinal = true;
          } else {
            interimTranscript = text;
          }
        }
        updateTextareaFromBuffers();
        if (sawFinal && liveState === "running") {
          scheduleNextChunk();
        }
      };

      recognition.onerror = (event) => {
        console.error("Speech recognition error", event);
        recognitionActive = false;
        shouldRestartRecognition = false;
        clearChunkTimer();
        if (liveState !== "idle") {
          const reason = event && event.error ? `: ${event.error}` : "";
          showVoiceError(`Speech recognition error${reason}`);
          liveState = "idle";
          updateLiveControls();
          setStatus("Speech error.");
        }
      };

      recognition.onend = async () => {
        recognitionActive = false;
        const stopMode = recognitionStopMode;
        recognitionStopMode = null;
        if (stopMode === "pause") {
          updateTextareaFromBuffers();
          setStatus("Paused (live)");
          return;
        }
        if (stopMode === "finish") {
          updateTextareaFromBuffers();
          await completeLiveSessionIfNeeded();
          return;
        }
        if (liveState === "running" && shouldRestartRecognition) {
          try {
            recognition.start();
          } catch (err) {
            console.error("Speech recognition restart failed", err);
            liveState = "idle";
            shouldRestartRecognition = false;
            updateLiveControls();
            showVoiceError("Could not restart speech recognition.");
            setStatus("Speech stopped.");
          }
          return;
        }
        if (pendingFinishSend) {
          updateTextareaFromBuffers();
          await completeLiveSessionIfNeeded();
        }
      };
    } else {
      if (startLiveBtn && pauseLiveBtn && finishLiveBtn) {
        const msg = "This browser does not support on-device speech recognition.";
        startLiveBtn.disabled = true;
        pauseLiveBtn.disabled = true;
        finishLiveBtn.disabled = true;
        startLiveBtn.title = msg;
        pauseLiveBtn.title = msg;
        finishLiveBtn.title = msg;
      }
    }

    function startLiveSession() {
      if (!SpeechRec || !recognition) {
        showVoiceError("On-device speech recognition not supported in this browser.");
        return;
      }
      if (liveState === "running") return;
      committedTranscript = transcriptInput.value.trim();
      interimTranscript = "";
      updateTextareaFromBuffers();
      lastSentTranscript = committedTranscript;
      shouldRestartRecognition = true;
      recognitionStopMode = null;
      pendingFinishSend = false;
      clearVoiceError();
      liveState = "running";
      updateLiveControls();
      try {
        recognition.start();
        setStatus("Listening…");
        scheduleNextChunk();
      } catch (err) {
        console.error("Speech recognition start failed", err);
        liveState = "idle";
        shouldRestartRecognition = false;
        updateLiveControls();
        showVoiceError("Couldn't start speech recognition: " + (err.message || "Unknown error"));
        setStatus("Live session unavailable.");
      }
    }

    function togglePauseResumeLive() {
      if (!SpeechRec || !recognition) return;
      if (liveState === "running") {
        liveState = "paused";
        shouldRestartRecognition = false;
        recognitionStopMode = "pause";
        clearChunkTimer();
        updateLiveControls();
        try {
          recognition.stop();
          setStatus("Pausing…");
        } catch (err) {
          console.error("Speech recognition pause failed", err);
          recognitionStopMode = null;
          setStatus("Paused (live)");
        }
      } else if (liveState === "paused") {
        shouldRestartRecognition = true;
        recognitionStopMode = null;
        liveState = "running";
        clearVoiceError();
        updateLiveControls();
        try {
          recognition.start();
          setStatus("Listening…");
          scheduleNextChunk();
        } catch (err) {
          console.error("Speech recognition resume failed", err);
          liveState = "idle";
          shouldRestartRecognition = false;
          updateLiveControls();
          showVoiceError("Couldn't resume speech recognition: " + (err.message || "Unknown error"));
          setStatus("Live session unavailable.");
        }
      }
    }

    async function finishLiveSession() {
      clearChunkTimer();
      shouldRestartRecognition = false;
      liveState = "idle";
      interimTranscript = "";
      updateTextareaFromBuffers();
      committedTranscript = transcriptInput.value.trim();
      pendingFinishSend = true;
      updateLiveControls();
      setStatus("Finishing live session…");
      if (SpeechRec && recognition && recognitionActive) {
        recognitionStopMode = "finish";
        try {
          recognition.stop();
          return;
        } catch (err) {
          console.error("Speech recognition stop failed", err);
        }
      }
      recognitionStopMode = null;
      await completeLiveSessionIfNeeded();
    }

    async function sendTranscriptChunkToWorker(force = false) {
      const fullTranscript = transcriptInput.value.trim();
      if (!force && (!fullTranscript || fullTranscript === lastSentTranscript)) return false;
      if (!navigator.onLine) {
        setStatus("Offline – storing notes locally.");
        return false;
      }
      try {
        setStatus("Updating notes…");
        clearVoiceError();
        const res = await postJSON("/text", buildVoiceRequestPayload(fullTranscript));
        const raw = await res.text();
        if (!res.ok) {
          const snippet = raw ? `: ${raw.slice(0, 200)}` : "";
          throw new Error(`Worker error ${res.status} ${res.statusText}${snippet}`);
        }
        let data;
        try {
          data = JSON.parse(raw);
        } catch (e) {
          console.error("Voice worker returned non-JSON:", raw);
          showVoiceError("AI response wasn't in the expected format. Please try again.");
          return false;
        }
        applyVoiceResult(data);
        lastSentTranscript = fullTranscript;
        if (liveState === "running") {
          setStatus("Listening (live)…");
        } else if (liveState === "paused") {
          setStatus("Paused (live)");
        } else {
          setStatus("Notes updated.");
        }
        return true;
      } catch (err) {
        console.error(err);
        showVoiceError("Voice AI failed: " + (err.message || "Unknown error"));
        if (liveState === "running") {
          setStatus("Update failed – will retry later.");
        } else {
          setStatus("Update failed.");
        }
        return false;
      }
    }

    function clearChunkTimer() {
      if (chunkTimerId) {
        clearTimeout(chunkTimerId);
        chunkTimerId = null;
      }
    }

    function scheduleNextChunk() {
      clearChunkTimer();
      if (liveState !== "running") return;
      chunkTimerId = setTimeout(async () => {
        await sendTranscriptChunkToWorker();
        scheduleNextChunk();
      }, LIVE_CHUNK_INTERVAL_MS);
    }

    // --- SETTINGS ---
    function loadLocalOrDefault(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        return JSON.parse(raw);
      } catch (_) { return fallback; }
    }

    async function loadStaticConfig() {
      // schema
      try {
        const local = loadLocalOrDefault(LS_SCHEMA_KEY, null);
        if (local) {
          applySectionSchema(local);
          schemaEditor.value = JSON.stringify(local, null, 2);
        } else {
          const res = await fetch("depot.output.schema.json", { cache: "no-store" });
          if (res.ok) {
            const data = await res.json();
            applySectionSchema(data.sections || data);
            schemaEditor.value = JSON.stringify(data.sections || data, null, 2);
          } else {
            applySectionSchema(SECTION_FALLBACK);
            schemaEditor.value = JSON.stringify(SECTION_FALLBACK, null, 2);
          }
        }
      } catch {
        applySectionSchema(SECTION_FALLBACK);
        schemaEditor.value = JSON.stringify(SECTION_FALLBACK, null, 2);
      }

      // checklist
      try {
        const local = loadLocalOrDefault(LS_CHECKLIST_KEY, null);
        if (local) {
          CHECKLIST_SOURCE = Array.isArray(local) ? local : (local.items || []);
          CHECKLIST_ITEMS = normaliseChecklistConfig(CHECKLIST_SOURCE);
          checklistEditor.value = JSON.stringify(CHECKLIST_SOURCE, null, 2);
        } else {
          const res = await fetch("checklist.config.json", { cache: "no-store" });
          if (res.ok) {
            const data = await res.json();
            CHECKLIST_SOURCE = Array.isArray(data) ? data : (data.items || []);
            CHECKLIST_ITEMS = normaliseChecklistConfig(CHECKLIST_SOURCE);
            checklistEditor.value = JSON.stringify(CHECKLIST_SOURCE, null, 2);
          } else {
            CHECKLIST_SOURCE = [];
            CHECKLIST_ITEMS = [];
            checklistEditor.value = "[]";
          }
        }
      } catch {
        CHECKLIST_SOURCE = [];
        CHECKLIST_ITEMS = [];
        checklistEditor.value = "[]";
      }

      refreshUiFromState();
    }

    settingsBtn.onclick = () => {
      settingsOverlay.style.display = "flex";
    };
    closeSettingsBtn.onclick = () => {
      settingsOverlay.style.display = "none";
    };
    settingsOverlay.addEventListener("click", (e) => {
      if (e.target === settingsOverlay) settingsOverlay.style.display = "none";
    });

    schemaSaveBtn.onclick = () => {
      try {
        const data = JSON.parse(schemaEditor.value);
        applySectionSchema(data);
        localStorage.setItem(LS_SCHEMA_KEY, JSON.stringify(data));
        refreshUiFromState();
        alert("Schema saved for this device.");
      } catch (err) {
        alert("Schema JSON invalid: " + err.message);
      }
    };
    schemaResetBtn.onclick = () => {
      localStorage.removeItem(LS_SCHEMA_KEY);
      applySectionSchema(SECTION_FALLBACK);
      schemaEditor.value = JSON.stringify(SECTION_FALLBACK, null, 2);
      refreshUiFromState();
    };

    checklistSaveBtn.onclick = () => {
      try {
        const data = JSON.parse(checklistEditor.value);
        CHECKLIST_SOURCE = Array.isArray(data) ? data : (data.items || []);
        CHECKLIST_ITEMS = normaliseChecklistConfig(CHECKLIST_SOURCE);
        localStorage.setItem(LS_CHECKLIST_KEY, JSON.stringify(CHECKLIST_SOURCE));
        renderChecklist(clarificationsEl, lastCheckedItems, lastMissingInfo);
        alert("Checklist saved for this device.");
      } catch (err) {
        alert("Checklist JSON invalid: " + err.message);
      }
    };
    checklistResetBtn.onclick = () => {
      localStorage.removeItem(LS_CHECKLIST_KEY);
      CHECKLIST_SOURCE = [];
      CHECKLIST_ITEMS = [];
      checklistEditor.value = "[]";
      renderChecklist(clarificationsEl, lastCheckedItems, lastMissingInfo);
    };

    // --- BOOT ---
    sendTextBtn.onclick = sendText;
    if (startLiveBtn) startLiveBtn.onclick = startLiveSession;
    if (pauseLiveBtn) pauseLiveBtn.onclick = togglePauseResumeLive;
    if (finishLiveBtn) finishLiveBtn.onclick = () => { finishLiveSession(); };
    transcriptInput.addEventListener("input", () => {
      if (liveState !== "running") {
        committedTranscript = transcriptInput.value.trim();
      }
      renderChecklist(clarificationsEl, lastCheckedItems, lastMissingInfo);
    });
    loadStaticConfig();
    renderChecklist(clarificationsEl, [], []);
    committedTranscript = transcriptInput.value.trim();
    lastSentTranscript = committedTranscript;
    updateLiveControls();
    setStatus("Idle");
  </script>
</body>
</html>
