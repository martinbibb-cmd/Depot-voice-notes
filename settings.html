<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Survey Brain – Settings</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --card: #ffffff;
      --border: #d4dbe5;
      --accent: #0f766e;
      --accent-soft: #14b8a6;
      --muted: #64748b;
      --danger: #b91c1c;
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
      color: #e2e8f0;
      min-height: 100vh;
      padding: 16px;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 16px;
    }
    header h1 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    header span {
      font-size: .75rem;
      color: #94a3b8;
    }
    a.back-link {
      margin-left: auto;
      font-size: .8rem;
      color: #7dd3fc;
      text-decoration: none;
    }
    a.back-link:hover {
      text-decoration: underline;
    }
    main {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 14px;
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 12px 14px 14px;
      color: #0f172a;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .card-header {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .card-header h2 {
      margin: 0;
      font-size: .9rem;
      text-transform: uppercase;
      letter-spacing: .05em;
    }
    .card-header span {
      font-size: .7rem;
      color: var(--muted);
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 4px;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 5px 12px 5px;
      font-size: .7rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #0f766e;
      color: white;
      white-space: nowrap;
    }
    button.secondary {
      background: rgba(148,163,184,.16);
      color: #0f172a;
    }
    button.danger {
      background: var(--danger);
      color: white;
    }
    button.small {
      padding: 3px 8px;
      font-size: .65rem;
      font-weight: 500;
    }
    button:disabled {
      opacity: .55;
      cursor: default;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: .65rem;
      border-radius: 999px;
      padding: 3px 8px;
      background: #e2e8f0;
      color: #0f172a;
    }
    .pill.small {
      font-size: .6rem;
    }
    .pill-tag {
      background: #ecfeff;
      border: 1px solid #e0f2fe;
      border-radius: 999px;
      padding: 2px 7px;
      font-size: .6rem;
      color: #0f172a;
    }
    .rows {
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      max-height: 60vh;
      overflow: auto;
    }
    .row {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) minmax(0, 2fr) auto;
      gap: 6px;
      padding: 6px 8px;
      align-items: flex-start;
      border-bottom: 1px solid #e2e8f0;
    }
    .row:last-child {
      border-bottom: none;
    }
    .row span.order {
      font-size: .65rem;
      color: var(--muted);
      min-width: 2rem;
    }
    .row input[type="text"] {
      width: 100%;
      font-size: .7rem;
      padding: 3px 5px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
    }
    .row textarea {
      width: 100%;
      font-size: .7rem;
      padding: 3px 5px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      resize: vertical;
      min-height: 38px;
    }
    .row-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .checklist-rows {
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      max-height: 60vh;
      overflow: auto;
    }
    .checklist-row {
      display: grid;
      grid-template-columns: auto minmax(0, 0.9fr) minmax(0, 1fr) minmax(0, 1.4fr) minmax(0, 2fr) minmax(0, 1fr) auto auto;
      gap: 4px;
      padding: 6px 8px;
      align-items: flex-start;
      border-bottom: 1px solid #e2e8f0;
    }
    .checklist-row:last-child {
      border-bottom: none;
    }
    .checklist-row span.order {
      font-size: .65rem;
      color: var(--muted);
      min-width: 1.5rem;
    }
    .checklist-row input[type="text"] {
      width: 100%;
      font-size: .65rem;
      padding: 3px 4px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
    }
    .status {
      font-size: .65rem;
      color: var(--muted);
      margin-top: 4px;
    }
    .status strong {
      color: #0f766e;
    }
    .status.error strong {
      color: var(--danger);
    }
    .hint {
      font-size: .65rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>Survey Brain Settings</h1>
    <span>Section schema & checklist config</span>
    <button id="forceReloadBtn" class="danger">Force reload / reset app data</button>
    <a href="index.html" class="back-link">← Back to app</a>
  </header>

  <main>
    <!-- Export Format Preferences -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>Export Format</h2>
        <span>Choose default file format for exports</span>
      </div>
      <div style="display: flex; gap: 12px; align-items: center;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="radio" name="exportFormat" value="json" id="formatJSON" checked>
          <span style="font-size: 0.75rem; font-weight: 600;">JSON (default)</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="radio" name="exportFormat" value="csv" id="formatCSV">
          <span style="font-size: 0.75rem; font-weight: 600;">CSV (Comma-Separated Values)</span>
        </label>
      </div>
      <p class="hint">
        This setting controls the format used when exporting depot notes, sessions, and automatic/AI notes.
        JSON exports include all data in a structured format, while CSV exports are optimized for spreadsheet applications.
      </p>
    </section>

    <!-- AI Instructions Configuration -->
    <section class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <h2>AI Instructions</h2>
        <span>Customize system prompts for AI agents</span>
      </div>

      <div class="toolbar">
        <button id="ai-save-btn" class="secondary">Save AI Instructions</button>
        <button id="ai-reset-btn" class="secondary">Reset to Defaults</button>
      </div>

      <p class="hint">
        These instructions control how the AI behaves in different contexts. Edit them to customize the AI's behavior for your specific needs.
      </p>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <label style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">Agent Chat Instructions</label>
          <textarea
            id="ai-agent-chat-instructions"
            style="font-family: monospace; font-size: 0.7rem; padding: 8px; border: 1px solid var(--border); border-radius: 8px; min-height: 300px; resize: vertical;"
            placeholder="Agent chat system prompt..."
          ></textarea>
          <p class="hint" style="margin: 0;">Used when the AI assistant chats with you about survey details.</p>
        </div>

        <div style="display: flex; flex-direction: column; gap: 8px;">
          <label style="font-size: 0.75rem; font-weight: 600; color: var(--muted);">Section Tweak Instructions</label>
          <textarea
            id="ai-tweak-section-instructions"
            style="font-family: monospace; font-size: 0.7rem; padding: 8px; border: 1px solid var(--border); border-radius: 8px; min-height: 300px; resize: vertical;"
            placeholder="Section tweak system prompt..."
          ></textarea>
          <p class="hint" style="margin: 0;">Used when the AI improves survey section notes based on your instructions.</p>
        </div>
      </div>

      <p class="status" id="ai-status"></p>
    </section>

    <!-- LEFT: section schema editor -->
    <section class="card">
      <div class="card-header">
        <h2>Depot sections</h2>
        <span>Edit the section list & order</span>
        <span class="pill small" id="sections-count-pill">0 sections</span>
      </div>

      <div class="toolbar">
        <button id="sections-add-btn">+ Add section</button>
        <button id="sections-save-btn" class="secondary">Save to browser</button>
        <button id="sections-export-btn" class="secondary">Export JSON</button>
        <button id="sections-import-btn" class="secondary">Import JSON</button>
      </div>
      <p class="hint">
        These control the section headings in the main app. The worker fills them with text, but the
        <strong>names & order are defined here</strong>. “Future plans” will always be kept last by the app.
      </p>

      <div class="rows" id="sections-rows"></div>

      <p class="status" id="sections-status">Loading sections…</p>
      <input type="file" id="sections-import-input" accept="application/json" style="display:none;">
    </section>

    <!-- RIGHT: checklist editor -->
    <section class="card">
      <div class="card-header">
        <h2>Survey checklist</h2>
        <span>Groups, IDs & hints</span>
        <span class="pill small" id="checklist-count-pill">0 items</span>
      </div>

      <div class="toolbar">
        <button id="checklist-add-btn">+ Add item</button>
        <button id="checklist-save-btn" class="secondary">Save to browser</button>
        <button id="checklist-export-btn" class="secondary">Export JSON</button>
        <button id="checklist-import-btn" class="secondary">Import JSON</button>
      </div>
      <p class="hint">
        Each item has a stable <strong>ID</strong>, a <strong>group</strong> label, an optional
        <strong>Depot section</strong> link, plus a visible label and hint. Click <strong>⋯</strong> to expand and edit
        <strong>AI templates</strong> (plainText & naturalLanguage). The worker uses these templates to generate section content.
      </p>

      <div class="checklist-rows" id="checklist-rows"></div>

      <p class="status" id="checklist-status">Loading checklist…</p>
      <input type="file" id="checklist-import-input" accept="application/json" style="display:none;">
    </section>
  </main>

  <script>
    // Storage keys (match index.html)
    const SECTION_STORAGE_KEY = "depot.sectionSchema";
    const LEGACY_SECTION_STORAGE_KEY = "surveybrain-schema";
    const CHECKLIST_STORAGE_KEY = "depot.checklistConfig";
    const AI_INSTRUCTIONS_STORAGE_KEY = "depot.aiInstructions";
    const LS_AUTOSAVE_KEY = "surveyBrainAutosave";
    const WORKER_URL_STORAGE_KEYS = ["depot.workerUrl", "depot-worker-url"];
    const ADDITIONAL_STORAGE_KEYS = [
      "depot-output-schema",
      "depot.notesSchema.v1",
      "depot-checklist-state"
    ];
    const FUTURE_PLANS_NAME = "Future plans";

    // --- Helpers ---
    function readJSONSafe(key) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (_) {
        return null;
      }
    }

    function clearStoredAppData() {
      const keys = new Set([
        SECTION_STORAGE_KEY,
        LEGACY_SECTION_STORAGE_KEY,
        CHECKLIST_STORAGE_KEY,
        LS_AUTOSAVE_KEY,
        ...WORKER_URL_STORAGE_KEYS,
        ...ADDITIONAL_STORAGE_KEYS
      ]);

      try {
        for (let i = 0; i < localStorage.length; i += 1) {
          const key = localStorage.key(i);
          if (!key) continue;
          const lower = key.toLowerCase();
          if (lower.includes("depot") || lower.includes("surveybrain")) {
            keys.add(key);
          }
        }
      } catch (err) {
        console.warn("Could not enumerate localStorage keys during reset", err);
      }

      keys.forEach((key) => {
        try {
          localStorage.removeItem(key);
        } catch (err) {
          console.warn("Failed to remove localStorage key", key, err);
        }
      });

      try {
        sessionStorage.clear();
      } catch (err) {
        console.warn("Session storage could not be cleared", err);
      }
    }

    function sanitiseSectionSchema(input) {
      const asArray = (value) => {
        if (!value) return [];
        if (Array.isArray(value)) return value;
        if (value && typeof value === "object" && Array.isArray(value.sections)) {
          return value.sections;
        }
        return [];
      };

      const rawEntries = asArray(input);
      const prepared = [];
      rawEntries.forEach((entry, idx) => {
        if (!entry) return;
        const rawName = entry.name ?? entry.section ?? entry.title ?? entry.heading;
        const name = typeof rawName === "string" ? rawName.trim() : "";
        if (!name || name === "Arse_cover_notes") return;
        const rawDescription = entry.description ?? entry.hint ?? "";
        const description = typeof rawDescription === "string"
          ? rawDescription.trim()
          : String(rawDescription || "").trim();
        const order = typeof entry.order === "number" ? entry.order : idx + 1;
        prepared.push({ name, description, order, idx });
      });

      prepared.sort((a, b) => {
        const aHasOrder = typeof a.order === "number";
        const bHasOrder = typeof b.order === "number";
        if (aHasOrder && bHasOrder && a.order !== b.order) {
          return a.order - b.order;
        }
        if (aHasOrder && !bHasOrder) return -1;
        if (!aHasOrder && bHasOrder) return 1;
        return a.idx - b.idx;
      });

      const unique = [];
      const seen = new Set();
      prepared.forEach((entry) => {
        if (seen.has(entry.name)) return;
        seen.add(entry.name);
        unique.push({
          name: entry.name,
          description: entry.description || "",
          order: entry.order
        });
      });

      // Keep Future plans last, ensure it exists
      let withoutFuture = unique.filter((entry) => entry.name !== FUTURE_PLANS_NAME);
      let future = unique.find((entry) => entry.name === FUTURE_PLANS_NAME);
      if (!future) {
        future = {
          name: FUTURE_PLANS_NAME,
          description: "Notes about any future work or follow-on visits.",
          order: withoutFuture.length + 1
        };
      } else if (!future.description) {
        future = {
          ...future,
          description: "Notes about any future work or follow-on visits."
        };
      }

      const final = [...withoutFuture, future].map((entry, idx) => ({
        name: entry.name,
        description: entry.description || "",
        order: idx + 1
      }));

      return final;
    }

    function sanitiseChecklistConfig(value) {
      const asArray = (input) => {
        if (!input) return [];
        if (Array.isArray(input)) return input;
        if (input && typeof input === "object" && Array.isArray(input.items)) {
          return input.items;
        }
        return [];
      };

      const entries = asArray(value);
      const seen = new Set();
      const cleaned = [];

      entries.forEach((item) => {
        if (!item) return;
        const id = item.id != null ? String(item.id).trim() : "";
        const label = item.label != null ? String(item.label).trim() : "";
        if (!id || !label || seen.has(id)) return;
        seen.add(id);
        cleaned.push({
          id,
          group: (item.group || item.category || "Checklist").trim(),
          section: (item.section || item.sectionName || item.depotSection || "").trim(),
          label,
          hint: (item.hint || item.description || "").trim()
        });
      });

      return cleaned;
    }

    async function fetchJSON(path) {
      try {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) return null;
        return await res.json();
      } catch (_) {
        return null;
      }
    }

    // --- Section editor state / rendering ---
    const sectionsRowsEl = document.getElementById("sections-rows");
    const sectionsStatusEl = document.getElementById("sections-status");
    const sectionsCountPill = document.getElementById("sections-count-pill");

    let sections = [];

    function renderSections() {
      sectionsRowsEl.innerHTML = "";
      if (!sections.length) {
        sectionsRowsEl.innerHTML = '<div class="row"><span class="order">–</span><div class="hint" style="grid-column: span 3;">No sections defined yet. Add your first section above.</div></div>';
        sectionsCountPill.textContent = "0 sections";
        return;
      }
      sectionsCountPill.textContent = sections.length + (sections.length === 1 ? " section" : " sections");

      sections.forEach((sec, idx) => {
        const row = document.createElement("div");
        row.className = "row";

        const orderSpan = document.createElement("span");
        orderSpan.className = "order";
        orderSpan.textContent = idx + 1;

        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = sec.name || "";
        nameInput.placeholder = "Section name";
        nameInput.oninput = () => {
          sections[idx].name = nameInput.value.trim();
        };

        const descInput = document.createElement("textarea");
        descInput.value = sec.description || "";
        descInput.placeholder = "Installer hint / description (optional)";
        descInput.oninput = () => {
          sections[idx].description = descInput.value.trim();
        };

        const controls = document.createElement("div");
        controls.className = "row-controls";

        const upBtn = document.createElement("button");
        upBtn.className = "small secondary";
        upBtn.textContent = "▲";
        upBtn.disabled = idx === 0;
        upBtn.onclick = () => {
          if (idx === 0) return;
          const tmp = sections[idx - 1];
          sections[idx - 1] = sections[idx];
          sections[idx] = tmp;
          renderSections();
        };

        const downBtn = document.createElement("button");
        downBtn.className = "small secondary";
        downBtn.textContent = "▼";
        downBtn.disabled = idx === sections.length - 1;
        downBtn.onclick = () => {
          if (idx === sections.length - 1) return;
          const tmp = sections[idx + 1];
          sections[idx + 1] = sections[idx];
          sections[idx] = tmp;
          renderSections();
        };

        const delBtn = document.createElement("button");
        delBtn.className = "small danger";
        delBtn.textContent = "✕";
        delBtn.onclick = () => {
          if (!confirm(`Remove section "${sec.name || "Untitled"}"?`)) return;
          sections.splice(idx, 1);
          renderSections();
        };

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(delBtn);

        row.appendChild(orderSpan);
        row.appendChild(nameInput);
        row.appendChild(descInput);
        row.appendChild(controls);
        sectionsRowsEl.appendChild(row);
      });
    }

    async function loadSections() {
      sectionsStatusEl.textContent = "Loading sections…";
      let used = "defaults";

      // 1) Read overrides from localStorage (new key then legacy)
      const overrideNew = readJSONSafe(SECTION_STORAGE_KEY);
      const overrideLegacy = !overrideNew ? readJSONSafe(LEGACY_SECTION_STORAGE_KEY) : null;

      let local = overrideNew || overrideLegacy;
      let defaults = null;

      // 2) Fetch defaults from depot.output.schema.json
      defaults = await fetchJSON("depot.output.schema.json");

      const candidate = sanitiseSectionSchema(
        Array.isArray(local) && local.length ? local : defaults
      );

      sections = candidate;
      sectionsStatusEl.innerHTML = `Loaded <strong>${sections.length}</strong> sections (${overrideNew || overrideLegacy ? "from browser storage" : "from depot.output.schema.json"}).`;
      renderSections();
    }

    function saveSectionsToLocal() {
      const cleaned = sanitiseSectionSchema(sections);
      // Store as { sections: [...] } for clarity
      const payload = { sections: cleaned };
      localStorage.setItem(SECTION_STORAGE_KEY, JSON.stringify(payload));
      sectionsStatusEl.innerHTML = `Saved <strong>${cleaned.length}</strong> sections to browser. Main app will pick these up on next load.`;
    }

    function exportSectionsJSON() {
      const cleaned = sanitiseSectionSchema(sections);
      const payload = { sections: cleaned };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `depot.sections.schema-${ts}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      sectionsStatusEl.innerHTML = `Exported <strong>${cleaned.length}</strong> sections as JSON file.`;
    }

    function importSectionsJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          const cleaned = sanitiseSectionSchema(data);
          sections = cleaned;
          localStorage.setItem(SECTION_STORAGE_KEY, JSON.stringify({ sections: cleaned }));
          renderSections();
          sectionsStatusEl.innerHTML = `Imported <strong>${cleaned.length}</strong> sections and saved to browser.`;
        } catch (err) {
          console.error(err);
          sectionsStatusEl.classList.add("error");
          sectionsStatusEl.innerHTML = `<strong>Error:</strong> Could not parse JSON file.`;
        }
      };
      reader.readAsText(file);
    }

    // --- Checklist editor state / rendering ---
    const checklistRowsEl = document.getElementById("checklist-rows");
    const checklistStatusEl = document.getElementById("checklist-status");
    const checklistCountPill = document.getElementById("checklist-count-pill");

    let checklist = [];

    function renderChecklistEditor() {
      checklistRowsEl.innerHTML = "";
      if (!checklist.length) {
        checklistRowsEl.innerHTML = '<div class="checklist-row"><span class="order">–</span><div class="hint" style="grid-column: span 5;">No checklist items yet. Add your first item above.</div></div>';
        checklistCountPill.textContent = "0 items";
        return;
      }
      checklistCountPill.textContent = checklist.length + (checklist.length === 1 ? " item" : " items");

      checklist.forEach((item, idx) => {
        const row = document.createElement("div");
        row.className = "checklist-row";

        const orderSpan = document.createElement("span");
        orderSpan.className = "order";
        orderSpan.textContent = idx + 1;

        const idInput = document.createElement("input");
        idInput.type = "text";
        idInput.value = item.id || "";
        idInput.placeholder = "ID (stable)";
        idInput.oninput = () => {
          checklist[idx].id = idInput.value.trim();
        };

        const groupInput = document.createElement("input");
        groupInput.type = "text";
        groupInput.value = item.group || "";
        groupInput.placeholder = "Group (e.g. Boiler & controls)";
        groupInput.oninput = () => {
          checklist[idx].group = groupInput.value.trim();
        };

        const sectionInput = document.createElement("input");
        sectionInput.type = "text";
        sectionInput.value = item.section || "";
        sectionInput.placeholder = "Depot section (optional)";
        sectionInput.oninput = () => {
          checklist[idx].section = sectionInput.value.trim();
        };

        const labelInput = document.createElement("input");
        labelInput.type = "text";
        labelInput.value = item.label || "";
        labelInput.placeholder = "Question / label";
        labelInput.oninput = () => {
          checklist[idx].label = labelInput.value.trim();
        };

        const hintInput = document.createElement("input");
        hintInput.type = "text";
        hintInput.value = item.hint || "";
        hintInput.placeholder = "Hint (optional)";
        hintInput.oninput = () => {
          checklist[idx].hint = hintInput.value.trim();
        };

        // Expand button to show plainText and naturalLanguage
        const expandBtn = document.createElement("button");
        expandBtn.className = "small secondary";
        expandBtn.textContent = "⋯";
        expandBtn.title = "Show/hide AI templates";
        expandBtn.style.fontSize = "1.2rem";
        expandBtn.style.padding = "2px 8px";

        const controls = document.createElement("div");
        controls.className = "row-controls";

        const upBtn = document.createElement("button");
        upBtn.className = "small secondary";
        upBtn.textContent = "▲";
        upBtn.disabled = idx === 0;
        upBtn.onclick = () => {
          if (idx === 0) return;
          const tmp = checklist[idx - 1];
          checklist[idx - 1] = checklist[idx];
          checklist[idx] = tmp;
          renderChecklistEditor();
        };

        const downBtn = document.createElement("button");
        downBtn.className = "small secondary";
        downBtn.textContent = "▼";
        downBtn.disabled = idx === checklist.length - 1;
        downBtn.onclick = () => {
          if (idx === checklist.length - 1) return;
          const tmp = checklist[idx + 1];
          checklist[idx + 1] = checklist[idx];
          checklist[idx] = tmp;
          renderChecklistEditor();
        };

        const delBtn = document.createElement("button");
        delBtn.className = "small danger";
        delBtn.textContent = "✕";
        delBtn.onclick = () => {
          if (!confirm(`Remove checklist item "${item.label || item.id || "Untitled"}"?`)) return;
          checklist.splice(idx, 1);
          renderChecklistEditor();
        };

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(delBtn);

        // Expandable section for AI templates
        const expandableSection = document.createElement("div");
        expandableSection.style.gridColumn = "1 / -1";
        expandableSection.style.display = "none";
        expandableSection.style.padding = "12px";
        expandableSection.style.background = "#f8fafc";
        expandableSection.style.borderRadius = "8px";
        expandableSection.style.marginTop = "8px";

        const templatesLabel = document.createElement("div");
        templatesLabel.style.fontSize = "0.75rem";
        templatesLabel.style.fontWeight = "600";
        templatesLabel.style.marginBottom = "8px";
        templatesLabel.textContent = "AI Templates (used by worker to generate section content)";

        const plainTextLabel = document.createElement("label");
        plainTextLabel.style.display = "block";
        plainTextLabel.style.fontSize = "0.7rem";
        plainTextLabel.style.marginTop = "8px";
        plainTextLabel.style.marginBottom = "4px";
        plainTextLabel.textContent = "Plain Text Template (bullet points):";

        const plainTextArea = document.createElement("textarea");
        plainTextArea.value = item.plainText || "";
        plainTextArea.placeholder = "Bullet-point style template for plainText...";
        plainTextArea.rows = 3;
        plainTextArea.style.width = "100%";
        plainTextArea.style.fontFamily = "monospace";
        plainTextArea.style.fontSize = "0.7rem";
        plainTextArea.style.padding = "8px";
        plainTextArea.style.border = "1px solid #d4dbe5";
        plainTextArea.style.borderRadius = "6px";
        plainTextArea.oninput = () => {
          checklist[idx].plainText = plainTextArea.value;
        };

        const naturalLanguageLabel = document.createElement("label");
        naturalLanguageLabel.style.display = "block";
        naturalLanguageLabel.style.fontSize = "0.7rem";
        naturalLanguageLabel.style.marginTop = "8px";
        naturalLanguageLabel.style.marginBottom = "4px";
        naturalLanguageLabel.textContent = "Natural Language Template (prose):";

        const naturalLanguageArea = document.createElement("textarea");
        naturalLanguageArea.value = item.naturalLanguage || "";
        naturalLanguageArea.placeholder = "Prose description template for naturalLanguage...";
        naturalLanguageArea.rows = 3;
        naturalLanguageArea.style.width = "100%";
        naturalLanguageArea.style.fontFamily = "monospace";
        naturalLanguageArea.style.fontSize = "0.7rem";
        naturalLanguageArea.style.padding = "8px";
        naturalLanguageArea.style.border = "1px solid #d4dbe5";
        naturalLanguageArea.style.borderRadius = "6px";
        naturalLanguageArea.oninput = () => {
          checklist[idx].naturalLanguage = naturalLanguageArea.value;
        };

        expandableSection.appendChild(templatesLabel);
        expandableSection.appendChild(plainTextLabel);
        expandableSection.appendChild(plainTextArea);
        expandableSection.appendChild(naturalLanguageLabel);
        expandableSection.appendChild(naturalLanguageArea);

        // Toggle expand button
        expandBtn.onclick = () => {
          const isHidden = expandableSection.style.display === "none";
          expandableSection.style.display = isHidden ? "block" : "none";
          expandBtn.textContent = isHidden ? "−" : "⋯";
        };

        row.appendChild(orderSpan);
        row.appendChild(idInput);
        row.appendChild(groupInput);
        row.appendChild(sectionInput);
        row.appendChild(labelInput);
        row.appendChild(hintInput);
        row.appendChild(expandBtn);
        row.appendChild(controls);
        row.appendChild(expandableSection);

        checklistRowsEl.appendChild(row);
      });
    }

    async function loadChecklist() {
      checklistStatusEl.textContent = "Loading checklist…";

      const override = sanitiseChecklistConfig(readJSONSafe(CHECKLIST_STORAGE_KEY));
      const defaultsRaw = await fetchJSON("checklist.config.json");
      const defaults = sanitiseChecklistConfig(defaultsRaw);

      const candidate = override.length ? override : defaults;
      checklist = candidate;

      const source = override.length ? "browser storage" : "checklist.config.json";
      checklistStatusEl.innerHTML = `Loaded <strong>${checklist.length}</strong> items (${source}).`;
      renderChecklistEditor();
    }

    function saveChecklistToLocal() {
      const cleaned = sanitiseChecklistConfig(checklist);
      const payload = { items: cleaned };
      localStorage.setItem(CHECKLIST_STORAGE_KEY, JSON.stringify(payload));
      checklistStatusEl.innerHTML = `Saved <strong>${cleaned.length}</strong> checklist items to browser.`;
    }

    function exportChecklistJSON() {
      const cleaned = sanitiseChecklistConfig(checklist);
      const payload = { items: cleaned };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const ts = new Date().toISOString().replace(/[:.]/g, "-");
      const filename = `depot.checklist-${ts}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      checklistStatusEl.innerHTML = `Exported <strong>${cleaned.length}</strong> checklist items as JSON file.`;
    }

    function importChecklistJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          const cleaned = sanitiseChecklistConfig(data);
          checklist = cleaned;
          localStorage.setItem(CHECKLIST_STORAGE_KEY, JSON.stringify({ items: cleaned }));
          renderChecklistEditor();
          checklistStatusEl.innerHTML = `Imported <strong>${cleaned.length}</strong> checklist items and saved to browser.`;
        } catch (err) {
          console.error(err);
          checklistStatusEl.classList.add("error");
          checklistStatusEl.innerHTML = `<strong>Error:</strong> Could not parse JSON file.`;
        }
      };
      reader.readAsText(file);
    }

    // --- Wire up buttons ---
    const forceReloadBtn = document.getElementById("forceReloadBtn");
    if (forceReloadBtn) {
      forceReloadBtn.addEventListener("click", () => {
        const confirmReset = confirm("This will clear all stored Survey Brain data on this device. Continue?");
        if (!confirmReset) return;
        const originalLabel = forceReloadBtn.textContent;
        forceReloadBtn.disabled = true;
        forceReloadBtn.textContent = "Resetting…";
        try {
          clearStoredAppData();
          window.location.replace("index.html");
        } catch (err) {
          console.error("Force reload/reset failed", err);
          alert("Failed to reset stored data. Please hard refresh the page.");
          forceReloadBtn.disabled = false;
          forceReloadBtn.textContent = originalLabel;
        }
      });
    }

    document.getElementById("sections-add-btn").onclick = () => {
      sections.push({
        name: "",
        description: "",
        order: sections.length + 1
      });
      renderSections();
    };
    document.getElementById("sections-save-btn").onclick = saveSectionsToLocal;
    document.getElementById("sections-export-btn").onclick = exportSectionsJSON;
    document.getElementById("sections-import-btn").onclick = () => {
      document.getElementById("sections-import-input").click();
    };
    document.getElementById("sections-import-input").onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      importSectionsJSON(file);
      e.target.value = "";
    };

    document.getElementById("checklist-add-btn").onclick = () => {
      checklist.push({
        id: "",
        group: "Checklist",
        section: "",
        label: "",
        hint: ""
      });
      renderChecklistEditor();
    };
    document.getElementById("checklist-save-btn").onclick = saveChecklistToLocal;
    document.getElementById("checklist-export-btn").onclick = exportChecklistJSON;
    document.getElementById("checklist-import-btn").onclick = () => {
      document.getElementById("checklist-import-input").click();
    };
    document.getElementById("checklist-import-input").onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      importChecklistJSON(file);
      e.target.value = "";
    };

    // --- Export Format Preferences ---
    function loadExportFormat() {
      const format = localStorage.getItem('exportFormat') || 'json';
      const radioBtn = document.getElementById(format === 'csv' ? 'formatCSV' : 'formatJSON');
      if (radioBtn) radioBtn.checked = true;
    }

    function saveExportFormat(format) {
      localStorage.setItem('exportFormat', format);
    }

    document.querySelectorAll('input[name="exportFormat"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        saveExportFormat(e.target.value);
      });
    });

    // --- AI Instructions ---
    function getDefaultAIInstructions() {
      return {
        agentChat: `You are an AI assistant helping with heating survey work for a British Gas style boiler installation surveyor.

You have access to:
- The current survey sections and notes
- The transcript of conversations
- Reference materials from the knowledge database

Your job is to:
1. Answer questions about the survey, products, pricing, or technical details
2. Provide helpful suggestions based on the context
3. Help fill in missing information
4. Be concise but accurate

SANITY CHECKING:
- Actively correct obvious transcription mistakes using the context provided (e.g., if a pipe size looks wrong, normalise it to the nearest standard size).
- Standard pipework sizes are 8/10mm (microbore), 15mm, 22mm, 28mm, and 35mm—prefer these when resolving ambiguities.
- Prefer the most recent reference material versions (e.g., the latest pricebook such as November 2025) when multiple versions exist.

IMPORTANT:
- Use the reference materials to provide accurate product specifications and pricing
- If you don't know something, say so
- Keep responses brief and actionable
- Focus on helping complete the survey accurately`,
        tweakSection: `You are an expert heating survey assistant helping to improve survey notes.

You will receive:
- A section name (e.g., "Needs", "New boiler and controls")
- Current plainText (bullet-point style, semicolon-separated)
- Current naturalLanguage (prose description)
- User instructions on how to improve the section

Your job is to:
1. Read the current section content carefully
2. Apply the user's improvement instructions
3. Return an improved version of the section that maintains the same format

IMPORTANT RULES:
- Keep the same section name
- Maintain the plainText format (semicolon-separated bullet points)
- Maintain the naturalLanguage format (clear prose)
- Apply the user's instructions precisely
- Only modify what the user asks to improve
- Keep the technical accuracy and detail level
- Do not add information that wasn't requested
- Correct any obvious transcription errors using the context provided, especially standard pipe sizes (8/10mm, 15mm, 22mm, 28mm, 35mm) and other common measurements. Normalise improbable values to the nearest sensible standard size.

You MUST respond with ONLY valid JSON matching this shape:

{
  "section": "[section name]",
  "plainText": "Improved bullet points; separated by semicolons;",
  "naturalLanguage": "Improved prose description."
}

Do not wrap the JSON in backticks or markdown.
Do not include any explanation outside the JSON.`
      };
    }

    function loadAIInstructions() {
      const defaults = getDefaultAIInstructions();
      try {
        const raw = localStorage.getItem(AI_INSTRUCTIONS_STORAGE_KEY);
        if (raw) {
          const stored = JSON.parse(raw);
          return {
            agentChat: stored.agentChat || defaults.agentChat,
            tweakSection: stored.tweakSection || defaults.tweakSection
          };
        }
      } catch (err) {
        console.warn("Failed to read AI instructions override", err);
      }
      return defaults;
    }

    function saveAIInstructions(instructions) {
      try {
        localStorage.setItem(AI_INSTRUCTIONS_STORAGE_KEY, JSON.stringify(instructions));
        document.getElementById('ai-status').textContent = "AI instructions saved successfully";
        setTimeout(() => {
          document.getElementById('ai-status').textContent = "";
        }, 3000);
      } catch (err) {
        alert("Unable to save AI instructions: " + (err?.message || err));
      }
    }

    function renderAIInstructions() {
      const instructions = loadAIInstructions();
      const agentChatArea = document.getElementById('ai-agent-chat-instructions');
      const tweakSectionArea = document.getElementById('ai-tweak-section-instructions');

      if (agentChatArea) {
        agentChatArea.value = instructions.agentChat;
      }
      if (tweakSectionArea) {
        tweakSectionArea.value = instructions.tweakSection;
      }
    }

    // AI Instructions event listeners
    document.getElementById('ai-save-btn')?.addEventListener('click', () => {
      const agentChatArea = document.getElementById('ai-agent-chat-instructions');
      const tweakSectionArea = document.getElementById('ai-tweak-section-instructions');

      const instructions = {
        agentChat: agentChatArea?.value || getDefaultAIInstructions().agentChat,
        tweakSection: tweakSectionArea?.value || getDefaultAIInstructions().tweakSection
      };

      saveAIInstructions(instructions);
    });

    document.getElementById('ai-reset-btn')?.addEventListener('click', () => {
      if (!confirm('Reset AI instructions to defaults? This cannot be undone.')) return;

      localStorage.removeItem(AI_INSTRUCTIONS_STORAGE_KEY);
      renderAIInstructions();
      document.getElementById('ai-status').textContent = "AI instructions reset to defaults";
      setTimeout(() => {
        document.getElementById('ai-status').textContent = "";
      }, 3000);
    });

    // --- Boot ---
    (async function boot() {
      await loadSections();
      await loadChecklist();
      loadExportFormat();
      renderAIInstructions();
    })();
  </script>
</body>
</html>
